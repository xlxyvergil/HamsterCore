# 玩家等级系统设计方案

## 1. 需求概述

根据"等级与经验.md"文件中的要求，我们需要实现一个独立的玩家等级系统，具体要求如下：
1. 玩家等级总共30级，默认0级
2. 每升一级需要1000 × (2 × 等级 - 1)
3. 从1级开始每级+1生命值
4. 从1级开始每级+20护盾值
5. 从1级开始每级+20基础护甲

新增需求：
6. 默认经验值的获取和原版经验值相同
7. 等级及经验值不会因死亡等情况重置

## 2. 系统架构设计

### 2.1 核心组件

#### 2.1.1 PlayerLevelCapability
用于存储玩家等级相关信息的独立Capability：
- 当前玩家等级 (int)
- 当前经验值 (int)

#### 2.1.2 PlayerLevelManager
处理等级计算和经验管理的业务逻辑类：
- 经验获取逻辑
- 等级升级判断
- 属性加成计算

#### 2.1.3 PlayerLevelEvents
事件监听器，处理与玩家等级相关的游戏事件：
- 经验获取事件
- 玎家登录/复活事件

#### 2.1.4 PlayerLevelUpEvent
自定义事件，用于在玩家等级发生变化时通知其他系统

### 2.2 数据流设计

```
原版经验获取 → PlayerLevelEvents → PlayerLevelManager → PlayerLevelCapability → 发布PlayerLevelUpEvent → PlayerCapabilityAttacher监听并重新初始化数据
```

## 3. 详细实现方案

### 3.1 玩家等级能力系统

创建独立的`PlayerLevelCapability`类用于存储玩家等级数据：

```java
public class PlayerLevelCapability implements INBTSerializable<CompoundTag> {
    private int playerlevel = 0;     // 当前玩家等级，避免与实体等级的level字段冲突
    private int experience = 0;      // 当前经验值
    
    // Getters and setters
    public int getPlayerLevel() { return playerlevel; }
    public void setPlayerLevel(int playerlevel) { this.playerlevel = playerlevel; }
    public int getExperience() { return experience; }
    public void setExperience(int experience) { this.experience = experience; }
    
    // 计算升级到下一级所需的经验值
    public int getNextLevelExperience() {
        return 1000 * (2 * playerlevel + 1); // 1000 × (2 × 玩家等级 + 1)
    }
    
    // 计算总经验值需求（到达某等级需要的总经验）
    public int getTotalExperienceForLevel(int targetLevel) {
        int total = 0;
        for (int i = 0; i < targetLevel; i++) {
            total += 1000 * (2 * i + 1);
        }
        return total;
    }
    
    // 计算当前等级已获得的经验值
    public int getCurrentLevelExperience() {
        if (playerlevel <= 0) return experience;
        return experience - getTotalExperienceForLevel(playerlevel);
    }
    
    // 计算当前等级升级所需的经验值
    public int getExperienceToNextLevel() {
        if (playerlevel >= 30) return 0; // 已达到最高等级
        return getNextLevelExperience() - getCurrentLevelExperience();
    }
    
    // INBTSerializable实现
    @Override
    public CompoundTag serializeNBT() {
        CompoundTag tag = new CompoundTag();
        tag.putInt("PlayerLevel", playerlevel);
        tag.putInt("Experience", experience);
        return tag;
    }

    @Override
    public void deserializeNBT(CompoundTag tag) {
        playerlevel = tag.getInt("PlayerLevel");
        experience = tag.getInt("Experience");
    }
}
```

### 3.2 玩家等级管理器

创建独立的`PlayerLevelManager`类处理等级计算和经验管理：

```java
public class PlayerLevelManager {
    
    // 添加经验值
    public static void addExperience(Player player, int amount) {
        player.getCapability(PlayerLevelCapability.CAPABILITY).ifPresent(cap -> {
            int newExperience = cap.getExperience() + amount;
            cap.setExperience(newExperience);
            
            // 检查是否升级
            checkLevelUp(player, cap);
        });
    }
    
    // 检查并处理升级
    private static void checkLevelUp(Player player, PlayerLevelCapability cap) {
        int currentPlayerLevel = cap.getPlayerLevel();
        int currentExp = cap.getExperience();
        
        // 检查是否达到下一级的经验要求
        if (currentPlayerLevel < 30) { // 最高等级为30级
            int expNeeded = cap.getTotalExperienceForLevel(currentPlayerLevel + 1);
            if (currentExp >= expNeeded) {
                cap.setPlayerLevel(currentPlayerLevel + 1);
                // 发布自定义的等级升级事件
                MinecraftForge.EVENT_BUS.post(new PlayerLevelUpEvent(player, cap.getPlayerLevel()));
                
                // 继续检查是否还能升级（一次获得大量经验的情况）
                checkLevelUp(player, cap);
            }
        }
    }
    
    // 获取生命值加成 (从1级开始每级+1生命值)
    public static int getHealthBonus(int playerLevel) {
        return (playerLevel >= 1) ? playerLevel : 0;
    }
    
    // 获取护盾值加成 (从1级开始每级+20护盾值)
    public static int getShieldBonus(int playerLevel) {
        return (playerLevel >= 1) ? playerLevel * 20 : 0;
    }
    
    // 获取基础护甲加成 (从1级开始每级+20基础护甲)
    public static int getBaseArmorBonus(int playerLevel) {
        return (playerLevel >= 1) ? playerLevel * 20 : 0;
    }
}
```

### 3.3 事件监听器

创建独立的`PlayerLevelEvents`类处理游戏事件：

```java
public class PlayerLevelEvents {
    
    // 监听玩家获得经验的事件
    @SubscribeEvent
    public static void onPlayerPickupXp(PlayerXpEvent.PickupXp event) {
        Player player = event.getEntity();
        ExperienceOrb orb = event.getOrb();
        // 添加与拾取的经验球相同数量的经验到我们的系统中
        PlayerLevelManager.addExperience(player, orb.value);
    }
    
    // 玩家登录时触发等级更新
    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        Player player = event.getEntity();
        player.getCapability(PlayerLevelCapability.CAPABILITY).ifPresent(cap -> {
            // 发布等级更新事件，触发PlayerCapabilityAttacher重新初始化数据
            MinecraftForge.EVENT_BUS.post(new PlayerLevelUpEvent(player, cap.getPlayerLevel()));
        });
    }
    
    // 玩家复活时触发等级更新
    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        Player player = event.getEntity();
        player.getCapability(PlayerLevelCapability.CAPABILITY).ifPresent(cap -> {
            // 发布等级更新事件，触发PlayerCapabilityAttacher重新初始化数据
            MinecraftForge.EVENT_BUS.post(new PlayerLevelUpEvent(player, cap.getPlayerLevel()));
        });
    }
}
```

### 3.4 等级升级事件

创建独立的`PlayerLevelUpEvent`事件类：

```java
public class PlayerLevelUpEvent extends Event {
    private final Player player;
    private final int playerLevel;
    
    public PlayerLevelUpEvent(Player player, int playerLevel) {
        this.player = player;
        this.playerLevel = playerLevel;
    }
    
    public Player getPlayer() {
        return player;
    }
    
    public int getPlayerLevel() {
        return playerLevel;
    }
}
```

### 3.5 与PlayerCapabilityAttacher的集成

在`PlayerCapabilityAttacher`中监听`PlayerLevelUpEvent`事件，并根据玩家等级重新初始化数据：

```java
public class PlayerCapabilityAttacher {
    // ... 其他代码 ...
    
    @SubscribeEvent
    public static void onPlayerLevelUp(PlayerLevelUpEvent event) {
        Player player = event.getPlayer();
        int playerLevel = event.getPlayerLevel();
        
        // 根据玩家等级重新初始化玩家能力数据
        initializePlayerCapabilities(player, playerLevel);
    }
    
    // 根据玩家等级初始化能力数据
    private static void initializePlayerCapabilities(Player player, int playerLevel) {
        // 计算各项属性加成
        int healthBonus = PlayerLevelManager.getHealthBonus(playerLevel);
        int shieldBonus = PlayerLevelManager.getShieldBonus(playerLevel);
        int baseArmorBonus = PlayerLevelManager.getBaseArmorBonus(playerLevel);
        
        // 应用生命值加成（通过属性修饰符）
        applyHealthModifier(player, healthBonus);
        
        // 应用护盾值加成（通过修改Capability中的基础值）
        applyShieldBonus(player, shieldBonus);
        
        // 应用基础护甲加成（通过修改Capability中的基础值）
        applyBaseArmorBonus(player, baseArmorBonus);
    }
    
    // 应用生命值修饰符
    private static void applyHealthModifier(Player player, int bonus) {
        AttributeInstance healthAttribute = player.getAttribute(Attributes.MAX_HEALTH);
        if (healthAttribute != null) {
            // 移除旧的修饰符
            AttributeModifier oldModifier = healthAttribute.getModifier(HEALTH_MODIFIER_UUID);
            if (oldModifier != null) {
                healthAttribute.removeModifier(oldModifier);
            }
            
            // 添加新的修饰符
            if (bonus > 0) {
                AttributeModifier modifier = new AttributeModifier(
                    HEALTH_MODIFIER_UUID,
                    "PlayerLevelHealthBonus",
                    bonus,
                    AttributeModifier.Operation.ADDITION
                );
                healthAttribute.addPermanentModifier(modifier);
                
                // 确保玩家当前生命值不超过新的最大生命值
                if (player.getHealth() > player.getMaxHealth()) {
                    player.setHealth((float) player.getMaxHealth());
                }
            }
        }
    }
    
    // 应用护盾值加成（修改Capability中的基础值）
    private static void applyShieldBonus(Player player, int bonus) {
        player.getCapability(EntityShieldCapability.CAPABILITY).ifPresent(shieldCap -> {
            // 这里假设有一个方法可以直接设置基础护盾值
            // 具体实现需要根据现有代码结构调整
            // 注意：这里使用的是玩家等级而不是实体等级
            shieldCap.setBaseShield(100 + bonus); // 假设基础护盾值为100
        });
    }
    
    // 应用基础护甲加成（修改Capability中的基础值）
    private static void applyBaseArmorBonus(Player player, int bonus) {
        player.getCapability(EntityArmorCapability.CAPABILITY).ifPresent(armorCap -> {
            // 这里假设有一个方法可以直接设置基础护甲值
            // 具体实现需要根据现有代码结构调整
            // 注意：这里使用的是玩家等级而不是实体等级
            armorCap.setBaseArmor(200 + bonus); // 基础护甲值为200
        });
    }
}
```

## 4. HUD界面显示

### 4.1 显示位置和样式

玩家等级将在HUD界面中显示：
- 位置：快捷道具栏左侧，距离快捷道具栏6像素
- 文字大小：12×12像素
- 显示格式：Lv.[当前等级]/[最高等级]
- 经验进度条：位于等级文字下方，参考护盾进度条的实现方式

### 4.2 渲染实现

需要创建一个客户端事件处理器来渲染玩家等级信息和经验进度条：

```java
@Mod.EventBusSubscriber(modid = HamsterCore.MOD_ID, value = Dist.CLIENT)
public class PlayerLevelHUDRenderer {
    
    // 经验条纹理资源位置
    private static final ResourceLocation EXPERIENCE_BAR_TEXTURE = 
        ResourceLocation.fromNamespaceAndPath(HamsterCore.MOD_ID, "textures/gui/experience_bar.png");
    
    @SubscribeEvent
    public static void onRenderGameOverlay(RenderGuiEvent.Post event) {
        Minecraft mc = Minecraft.getInstance();
        if (mc.options.renderDebug || mc.screen != null) {
            return;
        }
        
        Player player = mc.player;
        if (player == null) return;
        
        // 获取玩家等级
        player.getCapability(PlayerLevelCapability.CAPABILITY).ifPresent(cap -> {
            int playerLevel = cap.getPlayerLevel();
            
            // 设置渲染位置（快捷道具栏左侧，距离6像素）
            int x = event.getWindow().getGuiScaledWidth() / 2 - 91 - 6; // 91是快捷道具栏左侧到屏幕中心的距离
            int y = event.getWindow().getGuiScaledHeight() - 29; // 与快捷道具栏同一水平线
            
            // 渲染等级文本
            String levelText = "Lv." + playerLevel + "/30";
            Font font = mc.font;
            
            // 绘制文本（12x12像素大小）
            GuiGraphics guiGraphics = event.getGuiGraphics();
            guiGraphics.drawString(font, levelText, x - font.width(levelText), y, 0xFFFFFF);
            
            // 渲染经验进度条
            renderExperienceBar(guiGraphics, cap, x - font.width(levelText), y + 12);
        });
    }
    
    private static void renderExperienceBar(GuiGraphics guiGraphics, PlayerLevelCapability cap, int x, int y) {
        // 获取当前等级经验和升级所需经验
        int currentExp = cap.getCurrentLevelExperience();
        int expToNext = cap.getNextLevelExperience();
        
        // 计算经验条的填充比例
        float fillRatio = expToNext > 0 ? (float) currentExp / expToNext : 0;
        
        // 经验条背景
        guiGraphics.blit(EXPERIENCE_BAR_TEXTURE, x, y, 0, 0, 100, 5, 100, 10);
        
        // 经验条填充
        int fillWidth = (int) (100 * fillRatio);
        if (fillWidth > 0) {
            guiGraphics.blit(EXPERIENCE_BAR_TEXTURE, x, y, 0, 5, fillWidth, 5, 100, 10);
        }
    }
}
```

## 5. 独立性保证

### 5.1 独立的数据存储
- 玩家等级系统使用独立的`PlayerLevelCapability`进行数据存储
- 不依赖于PlayerCapabilityAttacher中的任何Capability
- 确保等级数据与其它能力数据完全隔离

### 5.2 独立的业务逻辑
- 玩家等级系统拥有独立的`PlayerLevelManager`处理所有等级相关逻辑
- 不在PlayerCapabilityAttacher中处理等级计算或经验管理
- 通过事件机制与其他系统通信

### 5.3 松耦合的系统集成
- 通过自定义的`PlayerLevelUpEvent`事件实现系统间通信
- PlayerCapabilityAttacher仅作为监听器响应等级变化事件
- 确保两个系统可以独立开发和维护

## 6. 属性加成计算规则

### 6.1 生命值加成规则
- 从1级开始，每级增加1点生命值
- 公式：生命值加成 = 玩家等级（如果玩家等级≥1）
- 例如：1级获得1生命值，2级获得2生命值，依此类推

### 6.2 护盾值加成规则
- 从1级开始，每级增加20点护盾值
- 公式：护盾值加成 = 玩家等级 × 20（如果玩家等级≥1）
- 例如：1级获得20护盾值，2级获得40护盾值，依此类推

### 6.3 基础护甲加成规则
- 从1级开始，每级增加20点基础护甲
- 公式：基础护甲加成 = 玩家等级 × 20（如果玩家等级≥1）
- 例如：1级获得20基础护甲，2级获得40基础护甲，依此类推

## 7. 经验值计算规则

### 7.1 升级所需经验值
- 每升一级需要的经验值 = 1000 × (2 × 当前玩家等级 - 1)
- 例如：1级升2级需要1000点经验，2级升3级需要3000点经验

### 7.2 累计经验值
- 到达某等级所需的总经验值 = Σ[1000 × (2 × i - 1)] for i from 1 to (目标等级-1)
- 例如：到达10级需要的总经验值 = 1000 + 3000 + 5000 + ... + 17000 = 90000点经验

## 8. 数据持久化

通过独立的Capability系统实现数据的持久化存储，确保玩家等级数据不会因为死亡或其他情况而丢失。Capability会自动处理数据的保存和加载。

## 9. 与现有系统的集成

### 9.1 属性系统集成
- 生命值加成通过属性修饰符机制应用
- 护盾值和基础护甲加成通过修改Capability中的基础值应用
- 与现有的Capability系统保持一致的设计模式

### 9.2 网络同步集成
- 使用现有的网络包系统进行数据同步
- 确保客户端和服务端数据一致性

## 10. 测试要点

1. 验证经验获取是否与原版一致
2. 验证等级升级是否正确计算
3. 验证生命值、护盾值和基础护甲加成是否正确应用
4. 验证数据在死亡、退出游戏等情况下的持久化
5. 验证多人游戏环境下的同步功能
6. 验证等级显示UI是否正确更新
7. 验证经验进度条是否正确显示

## 11. 扩展性考虑

该设计方案具有良好的扩展性，未来可以轻松添加以下功能：
1. 自定义经验获取途径
2. 更复杂的属性加成规则
3. 技能树系统
4. 等级相关成就系统
5. GUI界面显示玩家等级信息

## 12. 总结

本方案完全符合"等级与经验.md"文件中的要求，并且与现有架构保持一致：
1. 通过独立的Capability系统实现玩家等级数据持久化
2. 通过事件监听机制与原版经验系统集成
3. 使用自定义的PlayerLevelUpEvent事件来触发能力重新初始化
4. 玩家等级系统与PlayerCapabilityAttacher完全独立，避免冲突
5. 生命值加成通过属性修饰符实现
6. 护盾值和基础护甲加成通过修改Capability中的基础值实现，与现有PlayerCapabilityAttacher的处理方式一致
7. 使用playerlevel字段避免与实体等级的level字段冲突
8. PlayerCapabilityAttacher中使用玩家等级而非实体等级进行属性计算
9. 在HUD中添加了经验进度条，参考护盾进度条的实现方式

系统设计模块化，易于维护和扩展，确保了各组件之间的松耦合关系。同时，增加了HUD界面显示功能，按照指定的位置和样式显示玩家等级信息和经验进度条。