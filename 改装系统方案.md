# 改装系统方案

## 1. 系统概述

改装系统是一个基于词缀的物品增强系统，允许玩家为武器和装备安装改装件以获得额外的属性加成。系统完全参照Apotheosis-1.20的宝石系统实现，但改装件通过AffixAPI将词缀赋予物品，具体的属性效果由武器系统统一处理。

### 1.1 核心特性

- **数据驱动** - 改装件通过JSON文件定义，易于扩展
- **多词缀支持** - 每个改装件可以有任意数量的词缀效果，词缀数量由用户自定义
- **唯一性约束** - 支持unique标记，防止重复安装同一改装件
- **类别系统** - 区分通用改装件（8个）和特殊改装件（1个）
- **稀有度系统** - 每个改装件有固定的稀有度，影响权重和数值
- **可卸载** - 支持改装件的卸载，卸载时自动移除对应的词缀
- **词缀集成** - 通过AffixAPI添加/移除词缀

### 1.2 与宝石系统的区别

| 特性 | 宝石系统 | 改装件系统 |
|------|---------|-----------|
| 稀有度 | 同一宝石有多个稀有度 | 每个改装件固定稀有度 |
| 数值 | 同一宝石不同稀有度有不同数值 | 每个改装件数值固定 |
| 词缀数量 | 由稀有度决定 | 由用户在JSON中自定义 |
| 数据文件 | 一个宝石文件包含所有稀有度数值 | 每个改装件一个独立文件 |
| 效果处理 | 自己处理属性修饰符和事件 | 只添加词缀，由武器系统处理 |

### 1.3 安装和卸载改装件

#### 1.3.1 安装改装件的流程

1. **添加插槽**
   - 使用"改装插槽符文"道具（SIGIL_OF_SOCKETING）在锻造台上为物品添加插槽
   - 通过AddModificationSocketsRecipe配方实现
   - 一次添加1个插槽，最多添加9个插槽（8个通用插槽 + 1个特殊插槽）
   - 只有通过ItemAffixApplicableUtil.java判断的道具才能添加插槽

2. **安装改装件**
   - 使用"改装件"道具在锻造台上将改装件安装到物品上
   - 通过ModificationSocketingRecipe配方实现
   - 改装件会自动安装到第一个空的插槽中
   - 安装时调用AffixAPI.addAffix()为物品添加词缀
   - 如果改装件标记为unique，则同一物品上不能重复安装该改装件

#### 1.3.2 卸载改装件的流程

1. **卸载改装件**
   - 使用"改装卸载符文"道具（SIGIL_OF_WITHDRAWAL）在锻造台上卸载所有改装件
   - 通过ModificationWithdrawalRecipe配方实现
   - 卸载时会移除物品上所有已安装的改装件
   - 卸载时调用AffixAPI.removeAffix()移除对应的词缀
   - 被卸载的改装件会返还给玩家

#### 1.3.3 插槽道具说明

**改装插槽符文（SIGIL_OF_SOCKETING）**
- 用于为物品添加改装件插槽
- 稀有度：UNCOMMON
- 每次使用添加1个插槽
- 最多添加9个插槽（8个通用 + 1个特殊）

**改装卸载符文（SIGIL_OF_WITHDRAWAL）**
- 用于卸载物品上的所有改装件
- 稀有度：UNCOMMON
- 卸载后返还所有改装件

## 2. 核心组件

### 2.1 Modification（改装件定义）

改装件定义类，包含改装件的所有基本信息。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/Modification.java`

```java
public record Modification(
    ResourceLocation id,
    int weight,
    int quality,
    Set<ResourceLocation> dimensions,
    ModificationCategory category,
    boolean unique,
    DynamicHolder<LootRarity> rarity,
    List<ModificationAffix> affixes
) {
    public static final Codec<Modification> CODEC = RecordCodecBuilder.create(inst -> inst.group(
        ResourceLocation.CODEC.fieldOf("variant").forGetter(Modification::id),
        Codec.INT.fieldOf("weight").forGetter(Modification::weight),
        Codec.INT.fieldOf("quality").forGetter(Modification::quality),
        ResourceLocation.CODEC.listOf().fieldOf("dimensions").forGetter(Modification::dimensions),
        ModificationCategory.CODEC.fieldOf("category").forGetter(Modification::category),
        Codec.BOOL.optionalFieldOf("unique", false).forGetter(Modification::unique),
        LootRarity.HOLDER_CODEC.fieldOf("rarity").forGetter(Modification::rarity),
        ModificationAffix.LIST_CODEC.fieldOf("affixes").forGetter(Modification::affixes)
    ).apply(inst, Modification::new));

    public boolean canApplyTo(ItemStack socketed, ItemStack modification) {
        if (this.unique) {
            List<Modification> mods = SocketHelper.getModifications(socketed).stream()
                .filter(ModificationInstance::isValid)
                .map(ModificationInstance::modification)
                .map(DynamicHolder::get)
                .toList();
            if (mods.contains(this)) return false;
        }
        return ItemAffixApplicableUtil.isItemApplicableForAffix(socketed);
    }
}
```

### 2.2 ModificationItem（改装件物品）

改装件的物品形式，继承Item类。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/ModificationItem.java`

```java
public class ModificationItem extends Item {

    private static final String MODIFICATION = "Modification";
    private static final String UUID_ARRAY = "UUIDs";

    public ModificationItem(Properties properties) {
        super(properties);
    }

    public static void setModification(ItemStack modificationStack, Modification modification) {
        modificationStack.getOrCreateTag().putString(MODIFICATION, modification.getId().toString());
    }

    public static DynamicHolder<Modification> getModification(ItemStack modification) {
        if (!modification.hasTag()) {
            return ModificationRegistry.INSTANCE.emptyHolder();
        }
        try {
            CompoundTag tag = modification.getTag();
            return ModificationRegistry.INSTANCE.holder(new ResourceLocation(tag.getString(MODIFICATION)));
        } catch (ResourceLocationException ex) {
            return ModificationRegistry.INSTANCE.emptyHolder();
        }
    }

    public static List<UUID> getOrCreateUUIDs(CompoundTag tag, int numUUIDs) {
        if (numUUIDs == 0) return Collections.emptyList();
        if (tag.contains(UUID_ARRAY)) {
            ListTag list = tag.getList(UUID_ARRAY, Tag.TAG_INT_ARRAY);
            List<UUID> ret = new ArrayList<>(list.size());
            for (Tag t : list) {
                ret.add(NbtUtils.loadUUID(t));
            }
            if (ret.size() < numUUIDs) return generateAndSave(ret, numUUIDs, tag);
            return ret;
        }
        return generateAndSave(new ArrayList<>(numUUIDs), numUUIDs, tag);
    }

    private static List<UUID> generateAndSave(List<UUID> base, int amount, CompoundTag tag) {
        int needed = amount - base.size();
        for (int i = 0; i < needed; i++) {
            base.add(UUID.randomUUID());
        }
        ListTag list = new ListTag();
        for (UUID id : base) {
            list.add(NbtUtils.createUUID(id));
        }
        tag.put(UUID_ARRAY, list);
        return base;
    }

    @Override
    public void appendHoverText(ItemStack stack, Level level, List<Component> tooltip, TooltipFlag flag) {
        super.appendHoverText(stack, level, tooltip, flag);
        DynamicHolder<Modification> mod = getModification(stack);
        if (mod.isBound()) {
            tooltip.add(Component.literal(mod.get().rarity().get().getDisplayName().getString()).withStyle(mod.get().rarity().get().getColor()));
            for (ModificationAffix affix : mod.get().affixes()) {
                tooltip.add(Component.literal("  " + affix.type() + ": " + affix.value()));
            }
        }
    }
}
```

### 2.3 ModificationInstance（改装件实例）

改装件的运行时实例，包含改装件和上下文信息。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/ModificationInstance.java`

```java
public record ModificationInstance(DynamicHolder<Modification> modification, ItemStack modificationStack, UUID uuid) {

    public static ModificationInstance EMPTY = new ModificationInstance(
        ModificationRegistry.INSTANCE.emptyHolder(),
        ItemStack.EMPTY,
        UUID.randomUUID()
    );

    public static ModificationInstance socketed(ItemStack socketed, ItemStack modificationStack) {
        DynamicHolder<Modification> mod = ModificationItem.getModification(modificationStack);
        if (!mod.isBound()) return EMPTY;
        List<UUID> uuids = ModificationItem.getOrCreateUUIDs(modificationStack.getOrCreateTag(), mod.get().affixes().size());
        return new ModificationInstance(mod, modificationStack, uuids.get(0));
    }

    public static ModificationInstance unsocketed(ItemStack modificationStack) {
        DynamicHolder<Modification> mod = ModificationItem.getModification(modificationStack);
        if (!mod.isBound()) return EMPTY;
        List<UUID> uuids = ModificationItem.getOrCreateUUIDs(modificationStack.getOrCreateTag(), mod.get().affixes().size());
        return new ModificationInstance(mod, modificationStack, uuids.get(0));
    }

    public boolean isValid() {
        return this.modification.isBound() && !this.modificationStack.isEmpty();
    }

    public boolean isValidUnsocketed() {
        return this.isValid();
    }

    public boolean canApplyTo(ItemStack stack) {
        return this.modification.get().canApplyTo(stack, this.modificationStack);
    }

    public void applyAffixes(ItemStack stack) {
        for (ModificationAffix affix : this.modification.get().affixes()) {
            AffixAPI.addAffix(
                stack,
                this.modification.get().id().toString(),
                affix.type(),
                affix.value(),
                affix.operation(),
                this.uuid,
                "user"
            );
        }
    }

    public void removeAffixes(ItemStack stack) {
        AffixAPI.removeAffix(stack, this.uuid);
    }
}
```

### 2.4 ModificationCategory（改装件类别）

改装件类别枚举，区分通用和特殊改装件。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/ModificationCategory.java`

```java
public enum ModificationCategory {
    GENERAL,
    SPECIAL;

    public static final Codec<ModificationCategory> CODEC = Codec.STRING.xmap(
        str -> str.equals("special") ? SPECIAL : GENERAL,
        cat -> cat == SPECIAL ? "special" : "general"
    );
}
```

### 2.5 ModificationAffix（改装件词缀）

改装件的词缀定义，包含属性类型、操作类型、数值和来源。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/ModificationAffix.java`

```java
public record ModificationAffix(
    String type,
    String operation,
    double value,
    String source
) {
    public static final Codec<ModificationAffix> CODEC = RecordCodecBuilder.create(inst -> inst.group(
        Codec.STRING.fieldOf("type").forGetter(ModificationAffix::type),
        Codec.STRING.fieldOf("operation").forGetter(ModificationAffix::operation),
        Codec.DOUBLE.fieldOf("value").forGetter(ModificationAffix::value),
        Codec.STRING.fieldOf("source").forGetter(ModificationAffix::source)
    ).apply(inst, ModificationAffix::new));

    public static final Codec<List<ModificationAffix>> LIST_CODEC = Codec.list(CODEC);
}
```

### 2.6 ModificationRegistry（改装件注册表）

改装件的注册管理，负责加载和管理所有改装件。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/ModificationRegistry.java`

```java
public class ModificationRegistry extends WeightedDynamicRegistry<Modification> {

    public static final ModificationRegistry INSTANCE = new ModificationRegistry();

    public ModificationRegistry() {
        super(LOGGER, "modifications", true, false);
    }

    @Override
    protected void registerBuiltinCodecs() {
        this.registerDefaultCodec(loc("modification"), Modification.CODEC);
    }

    public static ItemStack createRandomModificationStack(RandomSource rand, ServerLevel level, float luck, Predicate<Modification>... filter) {
        Modification mod = ModificationRegistry.INSTANCE.getRandomItem(rand, luck, filter);
        if (mod == null) return ItemStack.EMPTY;
        return createModificationStack(mod);
    }

    public static ItemStack createModificationStack(Modification mod) {
        ItemStack stack = new ItemStack(Items.MODIFICATION.get());
        ModificationItem.setModification(stack, mod);
        return stack;
    }
}
```

### 2.7 SocketHelper（插槽助手）

处理物品的插槽操作。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/SocketHelper.java`

```java
public class SocketHelper {

    private static final String MODIFICATIONS = "Modifications";
    private static final String SOCKETS = "sockets";

    public static int getSockets(ItemStack stack) {
        return stack.getOrCreateTag().getInt(SOCKETS);
    }

    public static void setSockets(ItemStack stack, int sockets) {
        stack.getOrCreateTag().putInt(SOCKETS, sockets);
    }

    public static SocketedModifications getModifications(ItemStack stack) {
        if (!stack.hasTag() || !stack.getTag().contains(MODIFICATIONS)) {
            return SocketedModifications.EMPTY;
        }
        return SocketedModifications.CODEC.parse(NbtOps.INSTANCE, stack.getTag().getCompound(MODIFICATIONS))
            .resultOrPartial(LOGGER::error)
            .orElse(SocketedModifications.EMPTY);
    }

    public static void setModifications(ItemStack stack, SocketedModifications modifications) {
        stack.getOrCreateTag().put(MODIFICATIONS, SocketedModifications.CODEC.encodeStart(NbtOps.INSTANCE, modifications)
            .resultOrPartial(LOGGER::error)
            .orElse(new CompoundTag()));
    }

    public static boolean hasEmptySockets(ItemStack stack) {
        return getModifications(stack).stream().filter(m -> !m.isValid()).count() > 0;
    }

    public static int getFirstEmptySocket(ItemStack stack) {
        List<ModificationInstance> mods = getModifications(stack).mods();
        for (int i = 0; i < mods.size(); i++) {
            if (!mods.get(i).isValid()) {
                return i;
            }
        }
        return -1;
    }

    public static int getGeneralCount(ItemStack stack) {
        return (int) getModifications(stack).stream()
            .filter(m -> m.isValid())
            .filter(m -> m.modification().get().category() == ModificationCategory.GENERAL)
            .count();
    }

    public static int getSpecialCount(ItemStack stack) {
        return (int) getModifications(stack).stream()
            .filter(m -> m.isValid())
            .filter(m -> m.modification().get().category() == ModificationCategory.SPECIAL)
            .count();
    }
}
```

### 2.8 SocketedModifications（已安装的改装件）

存储已安装改装件的NBT数据。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/SocketedModifications.java`

```java
public record SocketedModifications(List<ModificationInstance> mods) {

    public static final SocketedModifications EMPTY = new SocketedModifications(List.of());

    public static final Codec<SocketedModifications> CODEC = RecordCodecBuilder.create(inst -> inst.group(
        ModificationInstance.LIST_CODEC.fieldOf("mods").forGetter(SocketedModifications::mods)
    ).apply(inst, SocketedModifications::new));

    public int size() {
        return this.mods.size();
    }

    public Stream<ModificationInstance> stream() {
        return this.mods.stream();
    }
}
```

## 3. 配方系统

### 3.1 ModificationSocketingRecipe（改装配方）

将改装件打入物品的配方。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/recipe/ModificationSocketingRecipe.java`

```java
public class ModificationSocketingRecipe extends ApothSmithingRecipe {

    private static final ResourceLocation ID = new ResourceLocation("hamstercore:socketing");

    public ModificationSocketingRecipe() {
        super(ID, Ingredient.EMPTY, Ingredient.of(Items.MODIFICATION.get()), ItemStack.EMPTY);
    }

    @Override
    public boolean matches(Container inv, Level pLevel) {
        ItemStack input = inv.getItem(BASE);
        ItemStack modificationStack = inv.getItem(ADDITION);
        ModificationInstance mod = ModificationInstance.unsocketed(modificationStack);
        if (!mod.isValidUnsocketed()) return false;
        if (!SocketHelper.hasEmptySockets(input)) return false;
        return mod.canApplyTo(input);
    }

    @Override
    public ItemStack assemble(Container inv, RegistryAccess regs) {
        ItemStack input = inv.getItem(BASE);
        ItemStack modificationStack = inv.getItem(ADDITION);

        ItemStack result = input.copy();
        result.setCount(1);
        int socket = SocketHelper.getFirstEmptySocket(result);
        List<ModificationInstance> mods = new ArrayList<>(SocketHelper.getModifications(result).mods());
        ModificationInstance modToInsert = ModificationInstance.socketed(result, modificationStack.copy());
        mods.set(socket, modToInsert);
        SocketHelper.setModifications(result, new SocketedModifications(mods));

        modToInsert.applyAffixes(result);

        return result;
    }

    @Override
    public boolean canCraftInDimensions(int pWidth, int pHeight) {
        return pWidth * pHeight >= 2;
    }

    @Override
    public ItemStack getResultItem(RegistryAccess regs) {
        return ItemStack.EMPTY;
    }

    @Override
    public ItemStack getToastSymbol() {
        return new ItemStack(Blocks.SMITHING_TABLE);
    }

    @Override
    public ResourceLocation getId() {
        return ID;
    }

    @Override
    public RecipeSerializer<?> getSerializer() {
        return Serializer.INSTANCE;
    }

    @Override
    public RecipeType<?> getType() {
        return RecipeType.SMITHING;
    }

    @Override
    public boolean isSpecial() {
        return true;
    }

    public static class Serializer implements RecipeSerializer<ModificationSocketingRecipe> {

        public static Serializer INSTANCE = new Serializer();

        @Override
        public ModificationSocketingRecipe fromJson(ResourceLocation pRecipeId, JsonObject pJson) {
            return new ModificationSocketingRecipe();
        }

        @Override
        public ModificationSocketingRecipe fromNetwork(ResourceLocation pRecipeId, FriendlyByteBuf pBuffer) {
            return new ModificationSocketingRecipe();
        }

        @Override
        public void toNetwork(FriendlyByteBuf pBuffer, ModificationSocketingRecipe pRecipe) {

        }
    }
}
```

### 3.2 ModificationWithdrawalRecipe（卸载配方）

从物品上卸载改装件的配方。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/recipe/ModificationWithdrawalRecipe.java`

```java
public class ModificationWithdrawalRecipe extends ApothSmithingRecipe implements ReactiveSmithingRecipe {

    private static final ResourceLocation ID = new ResourceLocation("hamstercore:withdrawal");

    public ModificationWithdrawalRecipe() {
        super(ID, Ingredient.EMPTY, Ingredient.of(Items.SIGIL_OF_WITHDRAWAL.get()), ItemStack.EMPTY);
    }

    @Override
    public boolean matches(Container pInv, Level pLevel) {
        ItemStack base = pInv.getItem(BASE);
        ItemStack sigils = pInv.getItem(ADDITION);
        return base.getCount() == 1 && sigils.getItem() == Items.SIGIL_OF_WITHDRAWAL.get()
            && SocketHelper.getModifications(base).stream().anyMatch(ModificationInstance::isValid);
    }

    @Override
    public ItemStack assemble(Container pInv, RegistryAccess regs) {
        ItemStack out = pInv.getItem(BASE).copy();
        if (out.isEmpty()) {
            return ItemStack.EMPTY;
        }
        SocketHelper.setModifications(out, SocketedModifications.EMPTY);
        return out;
    }

    @Override
    public void onCraft(Container inv, Player player, ItemStack output) {
        ItemStack base = inv.getItem(BASE);
        SocketedModifications mods = SocketHelper.getModifications(base);
        for (int i = 0; i < mods.size(); i++) {
            ItemStack stack = mods.get(i).modificationStack();
            if (!stack.isEmpty()) {
                mods.get(i).removeAffixes(base);
                stack.removeTagKey(ModificationItem.UUID_ARRAY);
                if (!player.addItem(stack)) {
                    Block.popResource(player.level(), player.blockPosition(), stack);
                }
            }
        }
        SocketHelper.setModifications(base, SocketedModifications.EMPTY);
    }

    @Override
    public RecipeSerializer<?> getSerializer() {
        return Serializer.INSTANCE;
    }

    @Override
    public RecipeType<?> getType() {
        return RecipeType.SMITHING;
    }

    @Override
    public boolean isSpecial() {
        return true;
    }

    public static class Serializer implements RecipeSerializer<ModificationWithdrawalRecipe> {

        public static Serializer INSTANCE = new Serializer();

        @Override
        public ModificationWithdrawalRecipe fromJson(ResourceLocation pRecipeId, JsonObject pJson) {
            return new ModificationWithdrawalRecipe();
        }

        @Override
        public ModificationWithdrawalRecipe fromNetwork(ResourceLocation pRecipeId, FriendlyByteBuf pBuffer) {
            return new ModificationWithdrawalRecipe();
        }

        @Override
        public void toNetwork(FriendlyByteBuf pBuffer, ModificationWithdrawalRecipe pRecipe) {

        }
    }
}
```

### 3.3 AddModificationSocketsRecipe（添加插槽配方）

为物品添加改装件插槽的配方。

**位置**: `src/main/java/com/xlxyvergil/hamstercore/modification/recipe/AddModificationSocketsRecipe.java`

```java
public class AddModificationSocketsRecipe extends ApothSmithingRecipe {

    private static final ResourceLocation ID = new ResourceLocation("hamstercore:add_sockets");

    public AddModificationSocketsRecipe() {
        super(ID, Ingredient.EMPTY, Ingredient.of(Items.SIGIL_OF_SOCKETING.get()), ItemStack.EMPTY);
    }

    @Override
    public boolean matches(Container inv, Level pLevel) {
        ItemStack base = inv.getItem(BASE);
        ItemStack sigil = inv.getItem(ADDITION);
        return base.getCount() == 1 
            && sigil.getItem() == Items.SIGIL_OF_SOCKETING.get()
            && SocketHelper.getSockets(base) == 0
            && ItemAffixApplicableUtil.isItemApplicableForAffix(base);
    }

    @Override
    public ItemStack assemble(Container inv, RegistryAccess regs) {
        ItemStack out = inv.getItem(BASE).copy();
        SocketHelper.setSockets(out, 9);
        List<ModificationInstance> mods = new ArrayList<>();
        for (int i = 0; i < 9; i++) {
            mods.add(ModificationInstance.EMPTY);
        }
        SocketHelper.setModifications(out, new SocketedModifications(mods));
        return out;
    }

    @Override
    public RecipeSerializer<?> getSerializer() {
        return Serializer.INSTANCE;
    }

    @Override
    public RecipeType<?> getType() {
        return RecipeType.SMITHING;
    }

    @Override
    public boolean isSpecial() {
        return true;
    }

    public static class Serializer implements RecipeSerializer<AddModificationSocketsRecipe> {

        public static Serializer INSTANCE = new Serializer();

        @Override
        public AddModificationSocketsRecipe fromJson(ResourceLocation pRecipeId, JsonObject pJson) {
            return new AddModificationSocketsRecipe();
        }

        @Override
        public AddModificationSocketsRecipe fromNetwork(ResourceLocation pRecipeId, FriendlyByteBuf pBuffer) {
            return new AddModificationSocketsRecipe();
        }

        @Override
        public void toNetwork(FriendlyByteBuf pBuffer, AddModificationSocketsRecipe pRecipe) {

        }
    }
}
```

**配方说明**:
- 消耗一个"改装插槽符文"道具
- 为物品一次性添加9个插槽（8个通用插槽 + 1个特殊插槽）
- 只有通过ItemAffixApplicableUtil.java判断的道具才能添加插槽
- 物品必须没有插槽才能添加（防止重复添加）

## 4. 改装件数据文件

### 4.1 文件结构

改装件数据文件位于`src/main/resources/data/hamstercore/modifications/`目录下。

```
src/main/resources/data/hamstercore/modifications/
├── general/
│   ├── attack_damage_boost_common.json
│   ├── attack_damage_boost_uncommon.json
│   ├── attack_damage_boost_rare.json
│   ├── attack_damage_boost_epic.json
│   ├── attack_damage_boost_mythic.json
│   ├── attack_speed_boost_common.json
│   ├── attack_speed_boost_uncommon.json
│   ├── attack_speed_boost_rare.json
│   ├── attack_speed_boost_epic.json
│   ├── attack_speed_boost_mythic.json
│   ├── movement_speed_boost_common.json
│   ├── movement_speed_boost_uncommon.json
│   ├── movement_speed_boost_rare.json
│   ├── movement_speed_boost_epic.json
│   ├── movement_speed_boost_mythic.json
│   └── ...
└── special/
    ├── legendary_power.json
    ├── ancient_mastery.json
    └── ...
```

### 4.2 JSON字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `variant` | String | 改装件ID |
| `weight` | int | 权重（用于随机生成） |
| `quality` | int | 质量 |
| `dimensions` | String[] | 可用的维度 |
| `category` | String | 类别（"general"或"special"） |
| `unique` | boolean | 是否唯一（可选） |
| `rarity` | String | 固定稀有度（"common", "uncommon", "rare", "epic", "mythic", "ancient"） |
| `affixes` | Array | 词缀列表（支持任意数量） |

### 4.3 词缀字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `type` | String | 属性类型（如"minecraft:generic.attack_damage"） |
| `operation` | String | 操作类型（"ADDITION", "MULTIPLY_BASE", "MULTIPLY_TOTAL"） |
| `value` | double | 固定数值 |
| `source` | String | 词缀来源，只能是"user"或"def" |

**source参数说明**:
- "user" - 表示该词缀来自用户改装件
- "def" - 表示该词缀来自默认定义
- 改装件系统统一使用"user"作为source参数

### 4.4 改装件示例

#### 4.4.1 单词缀改装件

```json
{
  "variant": "attack_damage_boost_common",
  "weight": 10,
  "quality": 0,
  "dimensions": [],
  "category": "general",
  "unique": true,
  "rarity": "common",
  "affixes": [
    {
      "type": "minecraft:generic.attack_damage",
      "operation": "ADDITION",
      "value": 1,
      "source": "user"
    }
  ]
}
```

#### 4.4.2 双词缀改装件

```json
{
  "variant": "attack_damage_boost_rare",
  "weight": 6,
  "quality": 2,
  "dimensions": [],
  "category": "general",
  "unique": true,
  "rarity": "rare",
  "affixes": [
    {
      "type": "minecraft:generic.attack_damage",
      "operation": "ADDITION",
      "value": 3.5,
      "source": "user"
    },
    {
      "type": "minecraft:generic.attack_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.05,
      "source": "user"
    }
  ]
}
```

#### 4.4.3 三词缀改装件

```json
{
  "variant": "combat_master_epic",
  "weight": 4,
  "quality": 3,
  "dimensions": [],
  "category": "general",
  "unique": true,
  "rarity": "epic",
  "affixes": [
    {
      "type": "minecraft:generic.attack_damage",
      "operation": "ADDITION",
      "value": 5,
      "source": "user"
    },
    {
      "type": "minecraft:generic.attack_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.1,
      "source": "user"
    },
    {
      "type": "minecraft:generic.movement_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.05,
      "source": "user"
    }
  ]
}
```

#### 4.4.4 四词缀改装件

```json
{
  "variant": "attack_damage_boost_mythic",
  "weight": 2,
  "quality": 4,
  "dimensions": [],
  "category": "general",
  "unique": true,
  "rarity": "mythic",
  "affixes": [
    {
      "type": "minecraft:generic.attack_damage",
      "operation": "ADDITION",
      "value": 7,
      "source": "user"
    },
    {
      "type": "minecraft:generic.attack_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.15,
      "source": "user"
    },
    {
      "type": "minecraft:generic.movement_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.08,
      "source": "user"
    },
    {
      "type": "minecraft:generic.max_health",
      "operation": "MULTIPLY_BASE",
      "value": 0.05,
      "source": "user"
    }
  ]
}
```

#### 4.4.5 特殊改装件（多词缀）

```json
{
  "variant": "legendary_power",
  "weight": 1,
  "quality": 5,
  "dimensions": [],
  "category": "special",
  "unique": true,
  "rarity": "mythic",
  "affixes": [
    {
      "type": "minecraft:generic.attack_damage",
      "operation": "MULTIPLY_BASE",
      "value": 0.5,
      "source": "user"
    },
    {
      "type": "minecraft:generic.attack_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.2,
      "source": "user"
    },
    {
      "type": "minecraft:generic.movement_speed",
      "operation": "MULTIPLY_BASE",
      "value": 0.1,
      "source": "user"
    },
    {
      "type": "minecraft:generic.max_health",
      "operation": "MULTIPLY_BASE",
      "value": 0.15,
      "source": "user"
    }
  ]
}
```

## 5. 物品注册

### 5.1 改装件物品

**位置**: `src/main/java/com/xlxyvergil/hamstercore/item/Items.java`

```java
public static final RegistryObject<Item> MODIFICATION = ITEMS.register("modification",
    () -> new ModificationItem(new Item.Properties().stacksTo(64)));
```

### 5.2 辅助物品

**改装插槽符文（SIGIL_OF_SOCKETING）**
- 用于为物品添加改装件插槽
- 稀有度：UNCOMMON
- 堆叠上限：1
- 使用方式：在锻造台上与物品结合
- 效果：一次性添加9个插槽（8个通用 + 1个特殊）
- 限制：只能为通过ItemAffixApplicableUtil.java判断的道具添加插槽

**改装卸载符文（SIGIL_OF_WITHDRAWAL）**
- 用于卸载物品上的所有改装件
- 稀有度：UNCOMMON
- 堆叠上限：1
- 使用方式：在锻造台上与物品结合
- 效果：卸载所有改装件并返还给玩家
- 限制：只能卸载有改装件的物品

```java
public static final RegistryObject<Item> SIGIL_OF_SOCKETING = ITEMS.register("sigil_of_socketing",
    () -> new Item(new Item.Properties().stacksTo(1).rarity(Rarity.UNCOMMON)));

public static final RegistryObject<Item> SIGIL_OF_WITHDRAWAL = ITEMS.register("sigil_of_withdrawal",
    () -> new Item(new Item.Properties().stacksTo(1).rarity(Rarity.UNCOMMON)));
```

### 5.3 创造模式标签页

**位置**: `src/main/java/com/xlxyvergil/hamstercore/item/CreativeTab.java`

```java
public class CreativeTab {

    public static final DeferredRegister<CreativeModeTab> CREATIVE_MODE_TABS = DeferredRegister.create(Registries.CREATIVE_MODE_TAB, HamsterCore.MODID);

    public static final RegistryObject<CreativeModeTab> HAMSTER_CORE_TAB = CREATIVE_MODE_TABS.register("hamster_core_tab",
        () -> CreativeModeTab.builder()
            .title(Component.translatable("itemGroup.hamstercore"))
            .icon(() -> new ItemStack(Items.MODIFICATION.get()))
            .displayItems((parameters, output) -> {
                output.accept(Items.MODIFICATION.get());
                output.accept(Items.SIGIL_OF_SOCKETING.get());
                output.accept(Items.SIGIL_OF_WITHDRAWAL.get());
            })
            .build());
}
```

## 6. 配方注册

**位置**: `src/main/java/com/xlxyvergil/hamstercore/recipe/RecipeSerializerRegistry.java`

```java
public class RecipeSerializerRegistry {

    public static void register() {
        Registry.register(BuiltInRegistries.RECIPE_SERIALIZER,
            new ResourceLocation(HamsterCore.MODID, "socketing"),
            ModificationSocketingRecipe.Serializer.INSTANCE);

        Registry.register(BuiltInRegistries.RECIPE_SERIALIZER,
            new ResourceLocation(HamsterCore.MODID, "withdrawal"),
            ModificationWithdrawalRecipe.Serializer.INSTANCE);

        Registry.register(BuiltInRegistries.RECIPE_SERIALIZER,
            new ResourceLocation(HamsterCore.MODID, "add_sockets"),
            AddModificationSocketsRecipe.Serializer.INSTANCE);
    }
}
```

## 7. 使用流程

### 7.1 安装改装件

1. **获取改装件** - 通过战利品、命令或其他方式获得改装件物品
2. **添加插槽** - 使用"插槽符文"为武器添加改装件插槽（最多9个）
3. **安装改装件** - 在锻造台中将改装件和武器结合
4. **验证** - 系统会检查：
   - 武器是否有空插槽
   - 改装件是否可以应用到该武器
   - 改装件是否唯一（如果标记为unique）
5. **应用词缀** - 改装件的词缀通过AffixAPI添加到武器
6. **保存数据** - 改装件信息保存到武器的NBT中

### 7.2 卸载改装件

1. **准备物品** - 准备已安装改装件的武器和"提取符文"
2. **执行卸载** - 在锻造台中结合武器和提取符文
3. **移除词缀** - 系统调用AffixAPI.removeAffix()移除所有改装件的词缀
4. **返回改装件** - 改装件以物品形式返回给玩家或掉落到地上
5. **清理数据** - 从武器的NBT中移除改装件信息

### 7.3 插槽数量限制

- **通用改装件** - 最多8个
- **特殊改装件** - 最多1个
- **总插槽数** - 最多9个

## 8. NBT数据结构

### 8.1 物品NBT结构

```json
{
  "sockets": 9,
  "Modifications": {
    "mods": [
      {
        "modification": "hamstercore:attack_damage_boost_common",
        "modificationStack": {
          "Modification": "hamstercore:attack_damage_boost_common",
          "UUIDs": [
            "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
          ]
        },
        "uuid": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
      },
      ...
    ]
  }
}
```

### 8.2 改装件物品NBT结构

```json
{
  "Modification": "hamstercore:attack_damage_boost_common",
  "UUIDs": [
    "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
  ]
}
```

## 9. 集成点

### 9.1 与ItemAffixApplicableUtil的集成

在改装件应用前，使用ItemAffixApplicableUtil.java验证物品是否可以接受改装。

```java
public boolean canApplyTo(ItemStack socketed, ItemStack modification) {
    if (this.unique) {
        List<Modification> mods = SocketHelper.getModifications(socketed).stream()
            .filter(ModificationInstance::isValid)
            .map(ModificationInstance::modification)
            .map(DynamicHolder::get)
            .toList();
        if (mods.contains(this)) return false;
    }
    return ItemAffixApplicableUtil.isItemApplicableForAffix(socketed);
}
```

### 9.2 与AffixAPI的集成

改装件通过AffixAPI添加和移除词缀。

**安装词缀**:
```java
public void applyAffixes(ItemStack stack) {
    for (ModificationAffix affix : this.modification.get().affixes()) {
        AffixAPI.addAffix(
            stack,
            this.modification.get().id().toString(),
            affix.type(),
            affix.value(),
            affix.operation(),
            this.uuid,
            "modification"
        );
    }
}
```

**移除词缀**:
```java
public void removeAffixes(ItemStack stack) {
    for (ModificationAffix affix : this.modification.get().affixes()) {
        AffixAPI.removeAffix(
            stack,
            this.modification.get().id().toString(),
            this.uuid
        );
    }
}
```

## 10. 关键特性总结

- **数据驱动** - 改装件通过JSON文件定义，易于扩展
- **多词缀支持** - 每个改装件可以有任意数量的词缀效果，词缀数量由用户在JSON中自定义
- **唯一性约束** - 支持unique标记，防止重复安装同一改装件
- **类别系统** - 区分通用改装件（8个）和特殊改装件（1个）
- **稀有度系统** - 每个改装件有固定的稀有度，影响权重和数值
- **可卸载** - 支持改装件的卸载，卸载时自动移除对应的词缀
- **词缀集成** - 通过AffixAPI添加/移除词缀
- **武器系统处理** - 所有属性效果由武器系统统一处理
- **完全参照宝石系统** - 安装和卸载方式与宝石系统完全一致
- **创造模式标签页** - 改装件和相关物品在创造模式标签页中显示

## 11. 开发计划

1. 创建核心类（Modification, ModificationItem, ModificationInstance等）
2. 实现插槽系统（SocketHelper, SocketedModifications）
3. 实现配方系统（ModificationSocketingRecipe, ModificationWithdrawalRecipe等）
4. 创建改装件数据文件
5. 注册物品和配方
6. 测试安装和卸载流程
7. 测试词缀效果
