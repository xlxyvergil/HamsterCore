# 改装系统实现方案（基于TACZ配件系统深度分析）

基于对TACZ配件系统的深度分析，本文档详细描述了改装系统的实现方案，包括特殊改装和通用改装两种类型。该方案完全参照TACZ配件装配模式实现。

## TACZ配件系统核心机制分析

通过对TACZ源码的深度分析，其配件系统核心机制如下：

### 1. NBT数据存储机制
- **配件存储**：配件数据以`Attachment{Type}`格式存储在枪械的NBT中
- **键值格式**：`Attachment{TYPE}`，例如`AttachmentSCOPE`、`AttachmentMUZZLE`
- **数据结构**：完整的ItemStack数据，包含ID、数量、标签等信息

### 2. 安装/卸载流程
- **安装**：`installAttachment()`方法将配件ItemStack数据写入枪械NBT
- **卸载**：`unloadAttachment()`方法将对应类型的配件数据从枪械NBT中移除
- **网络同步**：通过`ClientMessageRefitGun`和`ClientMessageUnloadAttachment`进行服务器同步

### 3. 界面交互方式
- **槽位显示**：`GunAttachmentSlot`显示当前配件，点击选择配件类型
- **配件选择**：`InventoryAttachmentSlot`显示背包中对应类型的配件
- **操作流程**：点击槽位→选择配件类型→显示可选配件→点击安装

## 改装系统设计

### 1. 改装件类型定义
```java
public enum AffixType {
    SPECIAL("special"),      // 特殊改装件
    GENERAL("general"),      // 通用改装件
    NONE;                    // 无改装件

    private final String name;

    AffixType(String name) {
        this.name = name;
    }

    AffixType() {
        this.name = this.name().toLowerCase();
    }

    public String getName() {
        return name;
    }
}
```

### 2. 改装件接口（参考IAttachment）
```java
public interface IAffix {
    /**
     * @return 如果物品类型为 IAffix 则返回显式转换后的实例，否则返回 null。
     */
    @Nullable
    static IAffix getIAffixOrNull(@Nullable ItemStack stack) {
        if (stack == null) {
            return null;
        }
        if (stack.getItem() instanceof IAffix iAffix) {
            return iAffix;
        }
        return null;
    }

    /**
     * 获取改装件ID
     */
    @Nonnull
    ResourceLocation getAffixId(ItemStack affixStack);

    /**
     * 设置改装件ID
     */
    void setAffixId(ItemStack affixStack, @Nullable ResourceLocation affixId);

    /**
     * 获取改装件类型
     */
    @Nonnull
    AffixType getType(ItemStack affixStack);

    /**
     * 获取改装件对应的NBT数据
     */
    CompoundTag getAffixNBTData(ItemStack affixStack);
}
```

### 3. 改装件物品实现（参考AttachmentItem）
```java
public class AffixItem extends Item implements IAffix {
    public static final String AFFIX_ID_TAG = "AffixId";
    public static final String AFFIX_TYPE_TAG = "AffixType";
    
    public AffixItem() {
        super(new Properties().stacksTo(1));
    }

    @Override
    @Nonnull
    public ResourceLocation getAffixId(ItemStack affixStack) {
        CompoundTag nbt = affixStack.getOrCreateTag();
        String idStr = nbt.getString(AFFIX_ID_TAG);
        return idStr.isEmpty() ? new ResourceLocation("hamstercore", "empty") : new ResourceLocation(idStr);
    }

    @Override
    public void setAffixId(ItemStack affixStack, @Nullable ResourceLocation affixId) {
        CompoundTag nbt = affixStack.getOrCreateTag();
        if (affixId != null) {
            nbt.putString(AFFIX_ID_TAG, affixId.toString());
        }
    }

    @Override
    @Nonnull
    public AffixType getType(ItemStack affixStack) {
        IAffix iAffix = IAffix.getIAffixOrNull(affixStack);
        if (iAffix != null) {
            ResourceLocation id = iAffix.getAffixId(affixStack);
            // 从配置中获取类型信息
            return getAffixTypeFromConfig(id);
        } else {
            return AffixType.NONE;
        }
    }

    @Override
    public CompoundTag getAffixNBTData(ItemStack affixStack) {
        ResourceLocation id = this.getAffixId(affixStack);
        // 从资源系统加载对应的NBT数据
        return loadAffixNBTData(id);
    }

    private AffixType getAffixTypeFromConfig(ResourceLocation affixId) {
        // 从配置文件加载改装件类型
        return AffixType.SPECIAL; // 实际实现会从配置加载
    }

    private CompoundTag loadAffixNBTData(ResourceLocation affixId) {
        // 从配置文件或资源加载NBT数据
        return new CompoundTag(); // 实际实现会从资源加载
    }
}
```

### 4. 可改装物品接口（参考IGun和GunItemDataAccessor）
```java
public interface IModifiableItem {
    String AFFIX_BASE = "Affix";
    String SPECIAL_AFFIX_TAG = "AffixSPECIAL";
    String GENERAL_AFFIX_BASE = "AffixGENERAL_"; // 0-7，共8个通用槽位
    
    /**
     * 获取指定槽位的改装件
     */
    @Nonnull
    ItemStack getAffix(ItemStack item, int slotIndex);

    /**
     * 安装改装件
     */
    void installAffix(@Nonnull ItemStack item, int slotIndex, @Nonnull ItemStack affix);

    /**
     * 卸载改装件
     */
    void unloadAffix(@Nonnull ItemStack item, int slotIndex);

    /**
     * 获取改装件槽位数量
     */
    default int getAffixSlotCount() {
        return 9; // 1个特殊槽位 + 8个通用槽位
    }

    /**
     * 检查是否允许在指定槽位安装改装件
     */
    boolean allowAffixAtSlot(ItemStack item, int slotIndex, ItemStack affix);

    /**
     * 检查是否允许指定类型的改装件
     */
    boolean allowAffixType(ItemStack item, AffixType type);
    
    /**
     * 获取改装件ID（参考getAttachmentId）
     */
    @Nonnull
    default ResourceLocation getAffixId(ItemStack item, int slotIndex) {
        CompoundTag nbt = item.getOrCreateTag();
        String key = getAffixNBTKey(slotIndex);
        if (nbt.contains(key, Tag.TAG_COMPOUND)) {
            CompoundTag affixTag = nbt.getCompound(key);
            if (affixTag.contains(IAffix.AFFIX_ID_TAG, Tag.TAG_STRING)) {
                ResourceLocation affixId = ResourceLocation.tryParse(affixTag.getString(IAffix.AFFIX_ID_TAG));
                return Objects.requireNonNullElse(affixId, new ResourceLocation("hamstercore", "empty"));
            }
        }
        return new ResourceLocation("hamstercore", "empty");
    }
    
    /**
     * 获取改装件NBT键名
     */
    default String getAffixNBTKey(int slotIndex) {
        if (slotIndex == 0) {
            return SPECIAL_AFFIX_TAG; // 特殊改装槽位
        } else if (slotIndex >= 1 && slotIndex <= 8) {
            return GENERAL_AFFIX_BASE + (slotIndex - 1); // 通用改装槽位 0-7
        }
        return "InvalidAffixSlot";
    }
}
```

### 5. 可改装物品NBT访问器（参考GunItemDataAccessor）
```java
public interface AffixItemDataAccessor extends IModifiableItem {
    @Override
    default ItemStack getAffix(ItemStack item, int slotIndex) {
        if (!allowAffixAtSlot(item, slotIndex, ItemStack.EMPTY)) {
            return ItemStack.EMPTY;
        }
        CompoundTag nbt = item.getOrCreateTag();
        String key = getAffixNBTKey(slotIndex);
        if (nbt.contains(key, Tag.TAG_COMPOUND)) {
            return ItemStack.of(nbt.getCompound(key));
        }
        return ItemStack.EMPTY;
    }

    @Override
    default void installAffix(@Nonnull ItemStack item, int slotIndex, @Nonnull ItemStack affix) {
        if (!allowAffixAtSlot(item, slotIndex, affix)) {
            return;
        }
        IAffix iAffix = IAffix.getIAffixOrNull(affix);
        if (iAffix == null) {
            return;
        }
        CompoundTag nbt = item.getOrCreateTag();
        String key = getAffixNBTKey(slotIndex);
        CompoundTag affixTag = new CompoundTag();
        affix.save(affixTag);
        nbt.put(key, affixTag);
        
        // 应用改装件的NBT数据到物品
        applyAffixNBTData(item, affix, slotIndex);
    }

    @Override
    default void unloadAffix(@Nonnull ItemStack item, int slotIndex) {
        if (!allowAffixAtSlot(item, slotIndex, ItemStack.EMPTY)) {
            return;
        }
        CompoundTag nbt = item.getOrCreateTag();
        String key = getAffixNBTKey(slotIndex);
        CompoundTag emptyTag = new CompoundTag();
        ItemStack.EMPTY.save(emptyTag);
        nbt.put(key, emptyTag);
        
        // 移除改装件的NBT数据
        removeAffixNBTData(item, slotIndex);
    }

    @Override
    default boolean allowAffixAtSlot(ItemStack item, int slotIndex, ItemStack affix) {
        if (slotIndex < 0 || slotIndex >= getAffixSlotCount()) {
            return false;
        }
        
        if (slotIndex == 0) {
            // 特殊槽位只允许特殊改装件
            return affix.isEmpty() || (IAffix.getIAffixOrNull(affix) != null && 
                    IAffix.getIAffixOrNull(affix).getType(affix) == AffixType.SPECIAL);
        } else {
            // 通用槽位只允许通用改装件
            return affix.isEmpty() || (IAffix.getIAffixOrNull(affix) != null && 
                    IAffix.getIAffixOrNull(affix).getType(affix) == AffixType.GENERAL);
        }
    }

    @Override
    default boolean allowAffixType(ItemStack item, AffixType type) {
        if (type == AffixType.SPECIAL) {
            return true; // 假设所有物品都支持特殊改装
        } else if (type == AffixType.GENERAL) {
            return true; // 假设所有物品都支持通用改装
        }
        return false;
    }
    
    /**
     * 应用改装件的NBT数据到物品
     */
    default void applyAffixNBTData(ItemStack item, ItemStack affix, int slotIndex) {
        // 通过AffixAPI将改装件的NBT数据应用到物品上
        // 具体实现根据AffixAPI来处理
    }
    
    /**
     * 移除改装件的NBT数据
     */
    default void removeAffixNBTData(ItemStack item, int slotIndex) {
        // 移除之前应用的改装数据
        // 具体实现根据AffixAPI来处理
    }
}
```

### 6. 改装槽位组件（参考GunAttachmentSlot和InventoryAttachmentSlot）
```java
public class AffixSlot extends Button implements IStackTooltip {
    private final int slotIndex;
    private final AffixType type;
    private final Inventory inventory;
    private final int itemIndex;
    private boolean selected = false;
    private ItemStack affixItem = ItemStack.EMPTY;

    public AffixSlot(int x, int y, int slotIndex, AffixType type, int itemIndex, Inventory inventory, Button.OnPress onPress) {
        super(x, y, 18, 18, Component.empty(), onPress, Button.DEFAULT_NARRATION);
        this.slotIndex = slotIndex;
        this.type = type;
        this.inventory = inventory;
        this.itemIndex = itemIndex;
    }

    @Override
    public void renderTooltip(Consumer<ItemStack> consumer) {
        if (this.isHoveredOrFocused() && !affixItem.isEmpty()) {
            consumer.accept(affixItem);
        }
    }

    @Override
    public void renderWidget(@NotNull GuiGraphics graphics, int pMouseX, int pMouseY, float pPartialTick) {
        ItemStack item = inventory.getItem(itemIndex);
        IModifiableItem modifiableItem = IModifiableItem.getIModifiableItemOrNull(item);
        if (modifiableItem == null) {
            return;
        }

        // 渲染外框
        int x = this.getX();
        int y = this.getY();
        RenderSystem.disableDepthTest();
        RenderSystem.enableBlend();
        if (isHoveredOrFocused() || selected) {
            graphics.blit(GunRefitScreen.SLOT_TEXTURE, x, y, 0, 0, width, height, 18, 18);
        } else {
            graphics.blit(GunRefitScreen.SLOT_TEXTURE, x + 1, y + 1, 1, 1, width - 2, height - 2, 18, 18);
        }

        // 渲染内部物品，或者空置时的icon
        this.affixItem = modifiableItem.getAffix(item, slotIndex);
        if (!affixItem.isEmpty()) {
            graphics.renderItem(affixItem, x + 1, y + 1);
        } else {
            // 渲染空槽位图标
            int xOffset = getSlotTextureXOffset(type);
            graphics.blit(GunRefitScreen.ICONS_TEXTURE, x + 2, y + 2, width - 4, height - 4, 
                         xOffset, 0, 32, 32, 224, 32);
        }

        RenderSystem.enableDepthTest();
        RenderSystem.disableBlend();
    }
    
    private int getSlotTextureXOffset(AffixType type) {
        switch (type) {
            case SPECIAL -> {
                return 0; // 特殊改装图标
            }
            case GENERAL -> {
                return 32; // 通用改装图标
            }
            default -> {
                return 192; // 不允许的类型图标
            }
        }
    }

    public void setSelected(boolean selected) {
        this.selected = selected;
    }

    public int getSlotIndex() {
        return slotIndex;
    }

    public AffixType getType() {
        return type;
    }

    public ItemStack getAffixItem() {
        ItemStack item = inventory.getItem(itemIndex);
        IModifiableItem modifiableItem = IModifiableItem.getIModifiableItemOrNull(item);
        if (modifiableItem == null) {
            return ItemStack.EMPTY;
        }
        return modifiableItem.getAffix(item, slotIndex);
    }
    
    public boolean isAllow() {
        ItemStack item = inventory.getItem(itemIndex);
        IModifiableItem modifiableItem = IModifiableItem.getIModifiableItemOrNull(item);
        if (modifiableItem == null) {
            return false;
        }
        return modifiableItem.allowAffixAtSlot(item, slotIndex, ItemStack.EMPTY);
    }
    
    public static IModifiableItem getIModifiableItemOrNull(ItemStack stack) {
        if (stack == null) {
            return null;
        }
        if (stack.getItem() instanceof IModifiableItem modifiableItem) {
            return modifiableItem;
        }
        return null;
    }
}
```

### 7. 改装界面（参考GunRefitScreen）
```java
public class AffixScreen extends Screen {
    public static final ResourceLocation SLOT_TEXTURE = new ResourceLocation("hamstercore", "textures/gui/affix_slot.png");
    public static final ResourceLocation UNLOAD_TEXTURE = new ResourceLocation("hamstercore", "textures/gui/affix_unload.png");
    public static final ResourceLocation ICONS_TEXTURE = new ResourceLocation("hamstercore", "textures/gui/affix_slot_icons.png");

    public static final int ICON_UV_SIZE = 32;
    public static final int SLOT_SIZE = 18;
    private static final int INVENTORY_AFFIX_SLOT_COUNT = 8; // 每页显示的背包改装件数量
    private static final int GENERAL_SLOT_START = 1; // 通用改装槽位起始索引
    private static final int GENERAL_SLOT_COUNT = 8; // 通用改装槽位数量

    private int currentPage = 0;
    private int currentSlotIndex = -1; // 当前选中的槽位索引

    private final ItemStack targetItem;
    private final Inventory inventory;
    private final int targetItemIndex;

    public AffixScreen(ItemStack targetItem, int targetItemIndex, Inventory inventory) {
        super(Component.literal("Affix Installation Screen"));
        this.targetItem = targetItem;
        this.targetItemIndex = targetItemIndex;
        this.inventory = inventory;
    }

    @Override
    public void init() {
        this.clearWidgets();
        
        // 添加改装件槽位（1个特殊改装槽位 + 8个通用改装槽位，水平排列贴着属性显示区右边）
        this.addAffixSlots();
        
        // 添加当前选中槽位类型的改装件列表
        this.addInventoryAffixButtons();
    }

    @Override
    public void render(@NotNull GuiGraphics graphics, int mouseX, int mouseY, float partialTick) {
        super.render(graphics, mouseX, mouseY, partialTick);

        // 渲染改装属性图（可选）
        renderAffixProperties(graphics);
    }

    private void addAffixSlots() {
        int startX = this.width / 2 + 100; // 贴着属性显示区域的右边
        int startY = this.height / 2 - 50; // 垂直居中位置，可根据实际属性显示区域调整

        // 特殊改装槽位（第1个）
        AffixSlot specialSlot = new AffixSlot(startX, startY, 0, AffixType.SPECIAL, targetItemIndex, inventory, b -> {
            int slotIndex = ((AffixSlot) b).getSlotIndex();
            // 如果是当前选中槽位，则取消选中；否则选中此槽位
            if (currentSlotIndex == slotIndex) {
                currentSlotIndex = -1;
            } else {
                currentSlotIndex = slotIndex;
            }
            this.init();
        });
        
        if (currentSlotIndex == 0) {
            specialSlot.setSelected(true);
            ItemStack affixInSlot = specialSlot.getAffixItem();
            if (!affixInSlot.isEmpty()) {
                // 添加卸载按钮
                AffixUnloadButton unloadButton = new AffixUnloadButton(startX + 5, startY + SLOT_SIZE + 2, b -> {
                    // 发送卸载网络包
                    NetworkHandler.CHANNEL.sendToServer(new ClientMessageUnloadAffix(targetItemIndex, 0));
                });
                this.addRenderableWidget(unloadButton);
            }
        }
        this.addRenderableWidget(specialSlot);

        // 通用改装槽位（8个）- 从左到右水平排列
        for (int i = 0; i < GENERAL_SLOT_COUNT; i++) {
            int slotIndex = GENERAL_SLOT_START + i;
            int slotX = startX + (i + 1) * SLOT_SIZE; // 水平排列，从左到右
            int slotY = startY;
            
            AffixSlot generalSlot = new AffixSlot(slotX, slotY, slotIndex, AffixType.GENERAL, targetItemIndex, inventory, b -> {
                int clickedSlotIndex = ((AffixSlot) b).getSlotIndex();
                if (currentSlotIndex == clickedSlotIndex) {
                    currentSlotIndex = -1;
                } else {
                    currentSlotIndex = clickedSlotIndex;
                }
                this.init();
            });
            
            if (currentSlotIndex == slotIndex) {
                generalSlot.setSelected(true);
                ItemStack affixInSlot = generalSlot.getAffixItem();
                if (!affixInSlot.isEmpty()) {
                    // 添加卸载按钮
                    AffixUnloadButton unloadButton = new AffixUnloadButton(slotX + 5, slotY + SLOT_SIZE + 2, b -> {
                        // 发送卸载网络包
                        NetworkHandler.CHANNEL.sendToServer(new ClientMessageUnloadAffix(targetItemIndex, slotIndex));
                    });
                    this.addRenderableWidget(unloadButton);
                }
            }
            this.addRenderableWidget(generalSlot);
        }
    }

    private void addInventoryAffixButtons() {
        if (currentSlotIndex < 0 || currentSlotIndex >= getAffixSlotCount()) {
            return; // 没有选中槽位，不显示可选改装件
        }

        AffixType requiredType = currentSlotIndex == 0 ? AffixType.SPECIAL : AffixType.GENERAL;
        int startX = this.width - 30;
        int startY = 50;
        int pageStart = currentPage * INVENTORY_AFFIX_SLOT_COUNT;
        int count = 0;
        int currentY = startY;
        
        for (int i = 0; i < inventory.getContainerSize(); i++) {
            ItemStack inventoryItem = inventory.getItem(i);
            IAffix affix = IAffix.getIAffixOrNull(inventoryItem);
            
            if (affix != null && affix.getType(inventoryItem) == requiredType) {
                // 检查目标物品是否允许安装此改装件
                IModifiableItem modifiableItem = AffixSlot.getIModifiableItemOrNull(targetItem);
                if (modifiableItem != null && modifiableItem.allowAffixAtSlot(targetItem, currentSlotIndex, inventoryItem)) {
                    count++;
                    if (count <= pageStart) {
                        continue;
                    }
                    if (count > pageStart + INVENTORY_AFFIX_SLOT_COUNT) {
                        continue;
                    }
                    
                    InventoryAffixSlot button = new InventoryAffixSlot(startX, currentY, i, inventory, b -> {
                        int slotIndex = ((InventoryAffixSlot) b).getSlotIndex();
                        // 发送安装网络包
                        NetworkHandler.CHANNEL.sendToServer(new ClientMessageInstallAffix(slotIndex, targetItemIndex, currentSlotIndex));
                    });
                    this.addRenderableWidget(button);
                    currentY = currentY + SLOT_SIZE;
                }
            }
        }
        
        // 添加翻页按钮
        int totalPage = (count - 1) / INVENTORY_AFFIX_SLOT_COUNT;
        addPageNavigationButtons(startX, startY, totalPage);
    }

    private int getAffixSlotCount() {
        IModifiableItem modifiableItem = AffixSlot.getIModifiableItemOrNull(targetItem);
        return modifiableItem != null ? modifiableItem.getAffixSlotCount() : 0;
    }

    private void addPageNavigationButtons(int startX, int startY, int totalPage) {
        if (currentPage < totalPage) {
            AffixTurnPageButton turnPageButtonDown = new AffixTurnPageButton(startX, startY + SLOT_SIZE * INVENTORY_AFFIX_SLOT_COUNT + 2, false, b -> {
                if (currentPage < totalPage) {
                    currentPage++;
                    init();
                }
            });
            this.addRenderableWidget(turnPageButtonDown);
        }
        if (currentPage > 0) {
            AffixTurnPageButton turnPageButtonUp = new AffixTurnPageButton(startX, startY - 10, true, b -> {
                if (currentPage > 0) {
                    currentPage--;
                    init();
                }
            });
            this.addRenderableWidget(turnPageButtonUp);
        }
    }

    private void renderAffixProperties(GuiGraphics graphics) {
        // 渲染改装属性图的实现
    }

    @Override
    public boolean isPauseScreen() {
        return false;
    }
}
```

### 8. 网络消息处理

#### 安装改装件消息
```java
public class ClientMessageInstallAffix {
    private final int affixSlotIndex;      // 背包中改装件的槽位索引
    private final int targetItemIndex;     // 目标物品的槽位索引
    private final int affixSlotTargetIndex; // 目标改装槽位索引

    public ClientMessageInstallAffix(int affixSlotIndex, int targetItemIndex, int affixSlotTargetIndex) {
        this.affixSlotIndex = affixSlotIndex;
        this.targetItemIndex = targetItemIndex;
        this.affixSlotTargetIndex = affixSlotTargetIndex;
    }

    public static void encode(ClientMessageInstallAffix message, FriendlyByteBuf buf) {
        buf.writeInt(message.affixSlotIndex);
        buf.writeInt(message.targetItemIndex);
        buf.writeInt(message.affixSlotTargetIndex);
    }

    public static ClientMessageInstallAffix decode(FriendlyByteBuf buf) {
        return new ClientMessageInstallAffix(buf.readInt(), buf.readInt(), buf.readInt());
    }

    public static void handle(ClientMessageInstallAffix message, Supplier<NetworkEvent.Context> contextSupplier) {
        NetworkEvent.Context context = contextSupplier.get();
        if (context.getDirection().getReceptionSide().isServer()) {
            context.enqueueWork(() -> {
                ServerPlayer player = context.getSender();
                if (player == null) {
                    return;
                }
                Inventory inventory = player.getInventory();
                ItemStack affixItem = inventory.getItem(message.affixSlotIndex);
                ItemStack targetItem = inventory.getItem(message.targetItemIndex);
                
                IModifiableItem modifiableItem = AffixSlot.getIModifiableItemOrNull(targetItem);
                if (modifiableItem != null) {
                    if (modifiableItem.allowAffixAtSlot(targetItem, message.affixSlotTargetIndex, affixItem)) {
                        ItemStack oldAffixItem = modifiableItem.getAffix(targetItem, message.affixSlotTargetIndex);
                        modifiableItem.installAffix(targetItem, message.affixSlotTargetIndex, affixItem);
                        
                        // 交换物品：将旧改装件放入背包，新改装件从背包移除
                        inventory.setItem(message.affixSlotIndex, oldAffixItem);
                        
                        player.inventoryMenu.broadcastChanges();
                        // 发送刷新界面消息
                        NetworkHandler.sendToClientPlayer(new ServerMessageRefreshAffixScreen(), player);
                    }
                }
            });
        }
        context.setPacketHandled(true);
    }
}
```

#### 卸载改装件消息
```java
public class ClientMessageUnloadAffix {
    private final int targetItemIndex;     // 目标物品的槽位索引
    private final int affixSlotIndex;      // 要卸载的改装槽位索引

    public ClientMessageUnloadAffix(int targetItemIndex, int affixSlotIndex) {
        this.targetItemIndex = targetItemIndex;
        this.affixSlotIndex = affixSlotIndex;
    }

    public static void encode(ClientMessageUnloadAffix message, FriendlyByteBuf buf) {
        buf.writeInt(message.targetItemIndex);
        buf.writeInt(message.affixSlotIndex);
    }

    public static ClientMessageUnloadAffix decode(FriendlyByteBuf buf) {
        return new ClientMessageUnloadAffix(buf.readInt(), buf.readInt());
    }

    public static void handle(ClientMessageUnloadAffix message, Supplier<NetworkEvent.Context> contextSupplier) {
        NetworkEvent.Context context = contextSupplier.get();
        if (context.getDirection().getReceptionSide().isServer()) {
            context.enqueueWork(() -> {
                ServerPlayer player = context.getSender();
                if (player == null) {
                    return;
                }
                Inventory inventory = player.getInventory();
                ItemStack targetItem = inventory.getItem(message.targetItemIndex);
                
                IModifiableItem modifiableItem = AffixSlot.getIModifiableItemOrNull(targetItem);
                if (modifiableItem != null) {
                    ItemStack affixItem = modifiableItem.getAffix(targetItem, message.affixSlotIndex);
                    if (!affixItem.isEmpty() && inventory.add(affixItem)) {
                        modifiableItem.unloadAffix(targetItem, message.affixSlotIndex);
                        
                        player.inventoryMenu.broadcastChanges();
                        // 发送刷新界面消息
                        NetworkHandler.sendToClientPlayer(new ServerMessageRefreshAffixScreen(), player);
                    }
                }
            });
        }
        context.setPacketHandled(true);
    }
}
```

## 与现有系统集成

### 1. 与ItemAffixApplicableUtil集成
- 使用`ItemAffixApplicableUtil.isItemApplicableForAffix()`判断物品是否支持改装
- 只有通过判断的物品才能使用改装系统

### 2. 与AffixAPI集成
- 改装件的NBT数据通过AffixAPI添加到武器
- 卸载改装件时移除对应的NBT数据

### 3. 改装件物品实现
- 创建特殊改装件和通用改装件的物品类
- 每个改装件包含特定的NBT数据，用于AffixAPI处理

## 系统特点

1. **完全参考TACZ模式**：NBT存储、安装/卸载流程、网络同步等完全参考TACZ实现
2. **双类型支持**：支持特殊改装（1槽）和通用改装（8槽）两种类型
3. **数据完整性**：改装件数据完整保存，包括ID、数量、标签等
4. **网络同步**：支持客户端-服务器同步，确保数据一致性
5. **界面友好**：提供直观的改装界面，水平排列槽位（特殊槽位在左，通用槽位在右），操作流程清晰

此方案基于对TACZ配件系统的深度分析，确保了与TACZ设计模式的一致性，同时满足项目需求。