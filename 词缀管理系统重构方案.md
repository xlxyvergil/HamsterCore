# 词缀管理系统重构方案

## 1. 设计目标

基于项目现有架构，对词缀管理系统进行重构，使其能够支持通用属性修饰符数据，不仅限于HamsterCore元素类型，还能兼容其他类型的属性修饰符（如Minecraft原版属性或其他mod的属性）。重构将保持与现有系统的兼容性，并参考Apotheosis的设计模式。

## 2. 系统架构

### 2.1 修改ElementCalculator（支持通用属性计算）

```java
public class ElementCalculator {
    public static final ElementCalculator INSTANCE = new ElementCalculator();

    private ElementCalculator() {}

    /**
     * 计算所有元素值，包括基础元素、复合元素、特殊元素和其他通用属性
     * @param weaponData 武器数据
     * @return 所有元素的计算值（保持String键名以支持通用属性）
     */
    public Map<String, Double> calculateAllElementValues(WeaponData weaponData) {
        Map<String, Double> elementValues = new HashMap<>();

        if (weaponData == null) {
            return elementValues;
        }

        // 直接从InitialModifiers层计算元素值（支持通用属性）
        Map<String, Double> initialElementValues = calculateElementValuesFromInitialModifiers(weaponData);

        // 转换为通用映射（保持所有属性，包括非HamsterCore属性）
        for (Map.Entry<String, Double> entry : initialElementValues.entrySet()) {
            elementValues.put(entry.getKey(), entry.getValue());
        }

        return elementValues;
    }

    /**
     * 从InitialModifiers层计算元素值（按name进行分组计算，模拟Forge属性修饰符计算）
     * @param weaponData 武器数据
     * @return 元素值映射
     */
    public Map<String, Double> calculateElementValuesFromInitialModifiers(WeaponData weaponData) {
        Map<String, Double> elementValues = new HashMap<>();

        if (weaponData == null) {
            return elementValues;
        }

        List<InitialModifierEntry> initialModifiers = weaponData.getInitialModifiers();

        // 按name分组，然后根据operation类型进行计算（模拟Forge属性修饰符计算）
        Map<String, List<InitialModifierEntry>> groupedModifiers = initialModifiers.stream()
            .collect(Collectors.groupingBy(InitialModifierEntry::getName));

        for (Map.Entry<String, List<InitialModifierEntry>> entry : groupedModifiers.entrySet()) {
            String name = entry.getKey();
            List<InitialModifierEntry> modifiers = entry.getValue();
            
            // 对同名修饰符进行合并计算（模拟Forge属性修饰符计算）
            double calculatedValue = calculateValueForName(modifiers);
            elementValues.put(name, calculatedValue);
        }

        return elementValues;
    }

    /**
     * 对同名修饰符进行合并计算（模拟Forge属性修饰符计算）
     * @param modifiers 同名的修饰符列表
     * @return 合并计算后的值
     */
    private double calculateValueForName(List<InitialModifierEntry> modifiers) {
        double baseValue = 0.0;
        double additionValue = 0.0;
        double multiplyBaseValue = 0.0; // MULTIPLY_BASE
        double multiplyTotalValue = 0.0; // MULTIPLY_TOTAL

        for (InitialModifierEntry entry : modifiers) {
            double amount = entry.getAmount();
            String operation = entry.getOperation();

            switch (operation.toUpperCase()) {
                case "ADDITION":
                    additionValue += amount;
                    break;
                case "MULTIPLY_BASE":
                    multiplyBaseValue += amount;
                    break;
                case "MULTIPLY_TOTAL":
                    multiplyTotalValue += amount;
                    break;
                default:
                    additionValue += amount; // 默认为ADDITION
                    break;
            }
        }

        // 计算最终值：(baseValue + additionValue) * (1 + multiplyBaseValue) * (1 + multiplyTotalValue)
        // 对于初始值，baseValue为0，所以结果是: additionValue * (1 + multiplyBaseValue) * (1 + multiplyTotalValue)
        double result = additionValue * (1 + multiplyBaseValue);
        result = result * (1 + multiplyTotalValue);

        return result;
    }

    /**
     * 获取激活的元素列表（包括HamsterCore元素和其他通用属性）
     * @param weaponData 武器数据
     * @return 激活的元素列表
     */
    public List<Map.Entry<String, Double>> getActivatedElements(WeaponData weaponData) {
        Map<String, Double> elementValues = calculateAllElementValues(weaponData);
        return elementValues.entrySet().stream()
                .filter(entry -> entry.getValue() > 0.0)
                .collect(Collectors.toList());
    }

    /**
     * 重新计算武器的元素数据
     * @param itemStack 物品栈
     */
    public void recalculateElementData(ItemStack itemStack) {
        if (itemStack.isEmpty()) {
            return;
        }

        // 现在由ElementCalculationCoordinator负责协调计算流程
        WeaponData weaponData = WeaponDataManager.loadElementData(itemStack);
        if (weaponData != null) {
            ElementCalculationCoordinator.INSTANCE.calculateAndStoreElements(itemStack, weaponData);
        }
    }
}
```

### 2.2 修改ElementCalculationCoordinator（支持通用属性存储）

```java
public class ElementCalculationCoordinator {
    public static final ElementCalculationCoordinator INSTANCE = new ElementCalculationCoordinator();
    
    private ElementCalculationCoordinator() {}
    
    /**
     * 计算元素值并将其存储到物品的NBT中
     * 支持HamsterCore元素和其他通用属性
     * @param stack 物品栈
     * @param weaponData 武器数据
     */
    public void calculateAndStoreElements(ItemStack stack, WeaponData weaponData) {
        // 1. 调用ElementCalculator从InitialModifiers层计算所有元素值（包括通用属性）
        Map<String, Double> elementValues = ElementCalculator.INSTANCE.calculateElementValuesFromInitialModifiers(weaponData);
        
        // 2. 分离需要复合计算的元素和其他通用属性
        Map<String, Double> elementsForCombination = new HashMap<>();
        Map<String, Double> otherAttributes = new HashMap<>(); // 存储其他通用属性（包括HamsterCore的非复合元素和其他mod属性）
        
        for (Map.Entry<String, Double> entry : elementValues.entrySet()) {
            String attributeName = entry.getKey();
            double value = entry.getValue();
            
            ElementType type = ElementType.byName(attributeName);
            if (type != null && (type.isBasic() || type.isComplex())) {
                // 需要复合计算的元素
                elementsForCombination.put(attributeName, value);
            } else {
                // 其他所有属性（包括HamsterCore的非复合元素和其他mod属性）统一存储
                otherAttributes.put(attributeName, value);
            }
        }
        
        // 3. 使用已分离的需要复合计算的元素
        
        // 4. 调用ElementCombinationModifier处理HamsterCore元素复合
        Map<String, Double> combinedElements = processElementCombinations(weaponData, elementsForCombination);
        
        // 5. 将计算结果存储到物品的NBT中，包括通用属性
        ElementUsageData.ElementData elementData = new ElementUsageData.ElementData();
        
        // 将其他通用属性存储到物理元素映射中（包括HamsterCore的非复合元素和其他mod属性，现作为通用属性存储）
        elementData.setPhysicalElements(otherAttributes);
        
        // 将复合后的元素存储到组合元素中
        elementData.setCombinedElements(combinedElements);
        
        ElementUsageData.writeElementDataToItem(stack, elementData);
    }
    
    /**
     * 从InitialModifiers层计算元素值（保持原有方法以兼容其他调用）
     * @param weaponData 武器数据
     * @return 元素值映射
     */
    private Map<String, Double> calculateElementValuesFromInitialModifiers(WeaponData weaponData) {
        Map<String, Double> elementValues = new HashMap<>();
        
        List<InitialModifierEntry> initialModifiers = weaponData.getInitialModifiers();
        
        // 按name分组，然后根据operation类型进行计算（模拟Forge属性修饰符计算）
        Map<String, List<InitialModifierEntry>> groupedModifiers = initialModifiers.stream()
            .collect(Collectors.groupingBy(InitialModifierEntry::getName));

        for (Map.Entry<String, List<InitialModifierEntry>> entry : groupedModifiers.entrySet()) {
            String name = entry.getKey();
            List<InitialModifierEntry> modifiers = entry.getValue();
            
            // 对同名修饰符进行合并计算（模拟Forge属性修饰符计算）
            double calculatedValue = calculateValueForName(modifiers);
            elementValues.put(name, calculatedValue);
        }
        
        return elementValues;
    }
    
    /**
     * 对同名修饰符进行合并计算（模拟Forge属性修饰符计算）
     * @param modifiers 同名的修饰符列表
     * @return 合并计算后的值
     */
    private double calculateValueForName(List<InitialModifierEntry> modifiers) {
        double baseValue = 0.0;
        double additionValue = 0.0;
        double multiplyBaseValue = 0.0; // MULTIPLY_BASE
        double multiplyTotalValue = 0.0; // MULTIPLY_TOTAL

        for (InitialModifierEntry entry : modifiers) {
            double amount = entry.getAmount();
            String operation = entry.getOperation();

            switch (operation.toUpperCase()) {
                case "ADDITION":
                    additionValue += amount;
                    break;
                case "MULTIPLY_BASE":
                    multiplyBaseValue += amount;
                    break;
                case "MULTIPLY_TOTAL":
                    multiplyTotalValue += amount;
                    break;
                default:
                    additionValue += amount; // 默认为ADDITION
                    break;
            }
        }

        // 计算最终值：(baseValue + additionValue) * (1 + multiplyBaseValue) * (1 + multiplyTotalValue)
        // 对于初始值，baseValue为0，所以结果是: additionValue * (1 + multiplyBaseValue) * (1 + multiplyTotalValue)
        double result = additionValue * (1 + multiplyBaseValue);
        result = result * (1 + multiplyTotalValue);

        return result;
    }
    
    /**
     * 处理元素复合
     * @param weaponData 武器数据
     * @param elementValues 元素值映射
     * @return 复合后的元素值映射
     */
    private Map<String, Double> processElementCombinations(WeaponData weaponData, Map<String, Double> elementValues) {
        // 创建一个临时的Map来存储复合结果
        Map<String, Double> tempValues = new HashMap<>(elementValues);
        
        // 调用ElementCombinationModifier处理元素复合，并直接使用返回的结果
        return ElementCombinationModifier.computeElementCombinationsWithValues(weaponData, tempValues);
    }
}
```

### 2.3 修改ElementUsageDataHandler（直接使用ElementUsageData中的数据）

```java
@Mod.EventBusSubscriber
public class ElementUsageDataHandler {
    
    /**
     * 处理物品属性修饰符事件
     * 直接从ElementUsageData中读取数据并生成AttributeModifier
     * 使用ElementUsageData中存储的UUID，不重新生成
     * 
     * @param event 物品属性修饰符事件
     */
    @SubscribeEvent
    public static void handleItemAttributeModifiers(ItemAttributeModifierEvent event) {
        ItemStack stack = event.getItemStack();
        
        // 检查物品是否在主手槽位
        if (event.getSlotType() != EquipmentSlot.MAINHAND) {
            return;
        }
        
        // 检查物品是否包含元素数据
        if (!ElementUsageData.hasElementData(stack)) {
            return;
        }
        
        // 从物品NBT中读取元素数据
        ElementUsageData.ElementData elementData = ElementUsageData.readElementDataFromItem(stack);
        
        // 从WeaponData获取所有InitialModifiers（用于生成AttributeModifier）
        WeaponData weaponData = WeaponDataManager.getWeaponData(stack);
        List<InitialModifierEntry> allModifiers = weaponData.getInitialModifiers();
        
        // 应用所有属性修饰符
        applyAllAttributes(event, stack, allModifiers);
    }
    
    /**
     * 应用所有属性修饰符
     */
    private static void applyAllAttributes(ItemAttributeModifierEvent event, ItemStack stack, List<InitialModifierEntry> modifiers) {
        // 直接应用每个属性修饰符
        for (InitialModifierEntry modifierEntry : modifiers) {
            applyAttributeModifier(event, stack, modifierEntry, event.getSlotType());
        }
    }
    
    /**
     * 应用单个属性修饰符
     */
    private static void applyAttributeModifier(ItemAttributeModifierEvent event, ItemStack stack, InitialModifierEntry modifierEntry, EquipmentSlot slot) {
        // 获取属性名称
        String attributeName = modifierEntry.getName();
        
        // 尝试获取Minecraft属性，如果获取不到则跳过
        Attribute attribute = getMinecraftAttributeById(attributeName);
        if (attribute == null) {
            return; // 如果属性不存在，则跳过
        }
        
        // 获取操作类型
        AttributeModifier.Operation operation = getOperationFromEntry(modifierEntry.getOperation());
        
        // 直接使用Entry中存储的UUID，不重新生成
        AttributeModifier modifier = new AttributeModifier(
            modifierEntry.getUuid(), // 使用Entry中存储的UUID
            "ElementUsageData." + attributeName, // 使用Entry中存储的name
            modifierEntry.getAmount(), // 使用Entry中存储的amount
            operation // 使用Entry中存储的operation
        );
        
        // 添加属性修饰符到事件
        event.addModifier(attribute, modifier);
    }
    
    /**
     * 从字符串获取操作类型
     */
    private static AttributeModifier.Operation getOperationFromEntry(String operationString) {
        switch (operationString.toUpperCase()) {
            case "MULTIPLY_BASE":
                return AttributeModifier.Operation.MULTIPLY_BASE;
            case "MULTIPLY_TOTAL":
                return AttributeModifier.Operation.MULTIPLY_TOTAL;
            default:
                return AttributeModifier.Operation.ADDITION;
        }
    }
    
    /**
     * 根据ID获取Minecraft属性
     */
    private static Attribute getMinecraftAttributeById(String attributeId) {
        try {
            // 尝试获取原生Minecraft属性或注册表中的属性
            ResourceLocation rl = new ResourceLocation(attributeId);
            return ForgeRegistries.ATTRIBUTES.getValue(rl);
        } catch (Exception e) {
            // 如果失败，返回null
            return null;
        }
    }
}
```

## 3. 与现有系统集成

### 3.1 保持向后兼容性

- 保留现有的ElementType枚举和相关API
- 保留现有的AffixAPI接口
- 保持现有的NBT结构兼容性
- 保持现有的所有类不变，仅修改实现

## 4. 实现步骤

1. 修改ElementCalculator类，支持按name进行分组和合并计算
2. 修改ElementCalculationCoordinator类，支持存储通用属性
3. 修改ElementUsageDataHandler类，直接使用InitialModifierEntry中的数据
4. 保持与现有系统的兼容性
5. 测试和验证功能

## 5. 系统特点

1. **通用性**：支持HamsterCore元素类型和其他类型的属性修饰符
2. **兼容性**：与现有系统完全兼容
3. **扩展性**：易于添加新的属性类型
4. **性能**：使用合并计算提高性能
5. **数据完整性**：完整保存词缀数据

## 6. 优势

1. **通用性**：系统现在支持任何Minecraft属性（原版或第三方mod）
2. **计算正确性**：按name进行分组计算，模拟Forge属性修饰符计算方式
3. **简化性**：ElementUsageDataHandler直接使用ElementUsageData中的数据，不进行计算
4. **灵活性**：支持HamsterCore元素、原生Minecraft属性和其他mod属性
5. **性能**：利用现有的复合逻辑，减少重复计算
6. **兼容性**：保持与现有代码的兼容性
7. **可扩展性**：易于扩展支持更多属性类型

此重构方案使整个系统能够支持通用属性修饰符，通过InitialModifierEntry的name字段可以引用任何Minecraft属性，并通过正确的计算方式（按name分组并根据operation类型计算）来处理这些属性。