# 改装道具实现方案

基于TACZ配件系统的设计理念和项目现有功能，本文档详细描述了改装道具的实现方案。

## 改装道具设计

### 1. 改装道具类型定义

```java
public enum AffixType {
    SPECIAL("special"),      // 特殊改装件
    GENERAL("general"),      // 通用改装件
    NONE;                   // 无改装件

    private final String name;

    AffixType(String name) {
        this.name = name;
    }

    AffixType() {
        this.name = this.name().toLowerCase();
    }

    public String getName() {
        return name;
    }
}
```

### 2. 改装道具接口

```java
public interface IAffix {
    /**
     * @return 如果物品类型为 IAffix 则返回显式转换后的实例，否则返回 null。
     */
    @Nullable
    static IAffix getIAffixOrNull(@Nullable ItemStack stack) {
        if (stack == null) {
            return null;
        }
        if (stack.getItem() instanceof IAffix iAffix) {
            return iAffix;
        }
        return null;
    }

    /**
     * 获取改装件ID
     */
    @Nonnull
    ResourceLocation getAffixId(ItemStack affixStack);

    /**
     * 设置改装件ID
     */
    void setAffixId(ItemStack affixStack, @Nullable ResourceLocation affixId);

    /**
     * 获取改装件类型
     */
    @Nonnull
    AffixType getType(ItemStack affixStack);

    /**
     * 获取改装件对应的NBT数据
     */
    CompoundTag getAffixNBTData(ItemStack affixStack);
}
```

### 3. 改装道具物品实现

```java
public class AffixItem extends Item implements IAffix {
    public static final String AFFIX_ID_TAG = "AffixId";
    public static final String AFFIX_TYPE_TAG = "AffixType";
    public static final String AFFIX_NBT_DATA_TAG = "AffixNBTData";
    
    private final AffixType affixType;
    private final ResourceLocation affixId;
    
    public AffixItem(AffixType type, ResourceLocation id, Properties properties) {
        super(properties.stacksTo(1));
        this.affixType = type;
        this.affixId = id;
    }

    @Override
    public ResourceLocation getAffixId(ItemStack affixStack) {
        CompoundTag nbt = affixStack.getOrCreateTag();
        String idStr = nbt.getString(AFFIX_ID_TAG);
        return idStr.isEmpty() ? this.affixId : ResourceLocation.tryParse(idStr);
    }

    @Override
    public void setAffixId(ItemStack affixStack, ResourceLocation affixId) {
        CompoundTag nbt = affixStack.getOrCreateTag();
        nbt.putString(AFFIX_ID_TAG, affixId.toString());
    }

    @Override
    public AffixType getType(ItemStack affixStack) {
        CompoundTag nbt = affixStack.getOrCreateTag();
        String typeStr = nbt.getString(AFFIX_TYPE_TAG);
        return typeStr.isEmpty() ? this.affixType : 
            "general".equals(typeStr) ? AffixType.GENERAL : AffixType.SPECIAL;
    }

    @Override
    public CompoundTag getAffixNBTData(ItemStack affixStack) {
        CompoundTag nbt = affixStack.getOrCreateTag();
        if (nbt.contains(AFFIX_NBT_DATA_TAG, Tag.TAG_COMPOUND)) {
            return nbt.getCompound(AFFIX_NBT_DATA_TAG);
        }
        // 从配置文件或资源加载默认NBT数据
        return loadDefaultNBTData(this.getAffixId(affixStack));
    }
    
    private CompoundTag loadDefaultNBTData(ResourceLocation affixId) {
        // 从配置文件加载对应改装件的NBT数据
        // 这些数据将通过AffixAPI应用到目标物品上
        return new CompoundTag();
    }
}
```

## 创造模式标签页实现

### 1. 创造模式标签页定义

```java
public class ModCreativeTabs {
    public static final CreativeModeTab AFFIX_ITEMS = CreativeModeTab.builder()
        .title(Component.translatable("itemGroup.hamstercore.affix_items"))
        .icon(() -> new ItemStack(ModItems.SPECIAL_AFFIX.get()))
        .displayItems((parameters, output) -> {
            // 添加特殊改装道具
            output.accept(new ItemStack(ModItems.SPECIAL_AFFIX.get()));
            
            // 添加通用改装道具
            for (RegistryObject<Item> item : ModItems.GENERAL_AFFIX_ITEMS) {
                if (item.get() instanceof AffixItem) {
                    output.accept(new ItemStack(item.get()));
                }
            }
        })
        .build();

    public static void register() {
        // 注册创造模式标签页
    }
}
```

### 2. 改装道具注册

```java
public class ModItems {
    // 特殊改装道具
    public static final RegistryObject<Item> SPECIAL_AFFIX = ITEMS.register("special_affix",
        () -> new AffixItem(AffixType.SPECIAL, new ResourceLocation("hamstercore", "special_affix"), 
            new Item.Properties()));

    // 通用改装道具示例
    public static final RegistryObject<Item> GENERAL_AFFIX_DAMAGE = ITEMS.register("general_affix_damage",
        () -> new AffixItem(AffixType.GENERAL, new ResourceLocation("hamstercore", "general_affix_damage"), 
            new Item.Properties()));

    public static final RegistryObject<Item> GENERAL_AFFIX_SPEED = ITEMS.register("general_affix_speed",
        () -> new AffixItem(AffixType.GENERAL, new ResourceLocation("hamstercore", "general_affix_speed"), 
            new Item.Properties()));

    // 通用改装道具列表
    public static final List<RegistryObject<Item>> GENERAL_AFFIX_ITEMS = new ArrayList<>();
    
    static {
        GENERAL_AFFIX_ITEMS.add(GENERAL_AFFIX_DAMAGE);
        GENERAL_AFFIX_ITEMS.add(GENERAL_AFFIX_SPEED);
        // 可以继续添加更多通用改装道具
    }

    public static final DeferredRegister<Item> ITEMS = DeferredRegister.create(ForgeRegistries.ITEMS, HamsterCore.MODID);
}
```

## 与AffixAPI集成

改装道具的NBT数据应该通过AffixAPI系统来影响目标物品的属性：

```java
// 在改装道具中定义NBT数据，这些数据将被AffixAPI处理
// 例如，一个增加伤害的改装道具可能包含如下NBT数据：
{
  "elementData": {
    "InitialModifiers": [
      {
        "attribute": "generic.attack_damage",
        "amount": 2.0,
        "operation": "ADDITION"
      }
    ]
  }
}
```

## 改装槽位UI布局

根据用户偏好，改装槽位UI布局如下：

- **位置**：紧贴属性显示区域的右侧
- **排列方式**：从左到右水平排列
- **槽位顺序**：左侧第一个为特殊槽位，后续8个为通用槽位

```java
private void addAffixSlots() {
    int startX = this.width / 2 + 100; // 贴着属性显示区域的右边
    int startY = this.height / 2 - 50; // 垂直居中位置，可根据实际属性显示区域调整

    // 特殊改装槽位（第1个）
    AffixSlot specialSlot = new AffixSlot(startX, startY, 0, AffixType.SPECIAL, targetItemIndex, inventory, b -> {
        int slotIndex = ((AffixSlot) b).getSlotIndex();
        // 如果是当前选中槽位，则取消选中；否则选中此槽位
        if (currentSlotIndex == slotIndex) {
            currentSlotIndex = -1;
        } else {
            currentSlotIndex = slotIndex;
        }
        this.init();
    });
    
    if (currentSlotIndex == 0) {
        specialSlot.setSelected(true);
        ItemStack affixInSlot = specialSlot.getAffixItem();
        if (!affixInSlot.isEmpty()) {
            // 添加卸载按钮
            AffixUnloadButton unloadButton = new AffixUnloadButton(startX + 5, startY + SLOT_SIZE + 2, b -> {
                // 发送卸载网络包
                NetworkHandler.CHANNEL.sendToServer(new ClientMessageUnloadAffix(targetItemIndex, 0));
            });
            this.addRenderableWidget(unloadButton);
        }
    }
    this.addRenderableWidget(specialSlot);

    // 通用改装槽位（8个）- 从左到右水平排列
    for (int i = 0; i < GENERAL_SLOT_COUNT; i++) {
        int slotIndex = GENERAL_SLOT_START + i;
        int slotX = startX + (i + 1) * SLOT_SIZE; // 水平排列，从左到右
        int slotY = startY;
        
        AffixSlot generalSlot = new AffixSlot(slotX, slotY, slotIndex, AffixType.GENERAL, targetItemIndex, inventory, b -> {
            int clickedSlotIndex = ((AffixSlot) b).getSlotIndex();
            if (currentSlotIndex == clickedSlotIndex) {
                currentSlotIndex = -1;
            } else {
                currentSlotIndex = clickedSlotIndex;
            }
            this.init();
        });
        
        if (currentSlotIndex == slotIndex) {
            generalSlot.setSelected(true);
            ItemStack affixInSlot = generalSlot.getAffixItem();
            if (!affixInSlot.isEmpty()) {
                // 添加卸载按钮
                AffixUnloadButton unloadButton = new AffixUnloadButton(slotX + 5, slotY + SLOT_SIZE + 2, b -> {
                    // 发送卸载网络包
                    NetworkHandler.CHANNEL.sendToServer(new ClientMessageUnloadAffix(targetItemIndex, slotIndex));
                });
                this.addRenderableWidget(unloadButton);
            }
        }
        this.addRenderableWidget(generalSlot);
    }
}
```

## 配置文件结构

创建配置文件来定义不同改装道具的效果：

```
config/hamstercore/affixes/
├── special_affixes.json
├── general_affixes.json
└── affix_mappings.json
```

## 系统特点

1. **遵循ElementType规范**：所有改装道具都遵循ElementType系统规范
2. **双类型支持**：支持特殊改装（1槽）和通用改装（8槽）两种类型
3. **数据完整性**：改装道具数据完整保存，包括ID、类型、NBT数据等
4. **界面友好**：改装槽位水平排列，特殊槽位在左，通用槽位在右
5. **与AffixAPI集成**：改装道具的NBT数据通过AffixAPI系统影响目标物品属性
6. **创造模式支持**：提供专门的创造模式标签页方便获取改装道具

此方案确保了改装道具与现有系统的兼容性，同时满足了用户的UI布局偏好。