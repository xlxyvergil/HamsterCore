# 元素属性系统具体实现步骤

## 一、创建元素属性基础结构

### 1. 定义 ElementType 枚举
**功能**：定义所有可用的元素类型常量
**含义**：这个枚举是整个元素属性系统的基础，它定义了游戏中所有可用的元素类型，包括：
- 物理元素（冲击、穿刺、切割）
- 基础元素（冰冻、电击、火焰、毒素）
- 复合元素（爆炸、腐蚀、毒气、磁力、辐射、病毒）

每个枚举值还包含元素的名称、显示名称、对应的颜色代码等信息，用于UI显示和日志记录。枚举还提供了元素组合规则的方法（如火焰+冰冻=爆炸）。

### 2. 创建 ElementAttribute 抽象基类
**功能**：定义元素属性的基本属性和行为
**含义**：这个抽象类是所有具体元素属性类的父类，它定义了：
- 元素属性的基本数据结构（元素类型、数值、持续时间等）
- 元素属性的应用方式（如何添加到物品上）
- 元素效果的计算方法（如何造成伤害或施加状态效果）
- 元素属性的显示信息（工具提示、图标等）

所有具体的元素类（如ImpactAttribute、BlastAttribute等）都将继承这个基类，并实现其抽象方法，从而保持一致的接口和行为。

### 3. 实现 ElementInstance 记录类
**功能**：表示一个具体的元素属性实例
**含义**：这个类是一个记录类（Record），用于表示装备上的一个具体元素属性，包含：
- 元素属性类型（引用ElementAttribute对象）
- 数值大小（元素伤害值或效果强度）
- 持续时间（对于状态效果）
- 触发条件（何时触发此元素效果）

ElementInstance作为连接ElementAttribute和实际应用的桥梁，它存储了元素属性在特定物品上的具体数值和状态。例如，一把剑可能有"火焰伤害10"的ElementInstance，其中"火焰伤害"是ElementAttribute，"10"是数值。

## 二、实现元素属性存储和注册

### 4. 创建 ElementRegistry 注册系统
**功能**：管理和注册所有元素类型
**含义**：这个类是一个全局注册表，负责：
- 在游戏启动时注册所有元素类型
- 提供元素类型的查找和访问接口
- 管理元素类型的生命周期（加载、卸载、重新加载）
- 支持从配置文件动态加载自定义元素

ElementRegistry是元素属性系统的核心管理器，它确保所有元素类型都能被系统识别和使用，类似于Minecraft原版的注册表系统。

### 5. 实现 ElementHelper 工具类
**功能**：提供元素属性的常用操作方法
**含义**：这个类包含了一系列静态实用方法，用于：
- 读取和写入物品上的元素属性（NBT操作）
- 计算元素属性的组合效果
- 验证元素属性的有效性
- 格式化元素属性的显示文本

ElementHelper简化了元素属性的常见操作，避免代码重复，并提供了一致的操作接口。

### 6. 设计NBT存储结构
**功能**：定义元素属性在物品NBT中的存储格式
**含义**：这部分设计决定了元素属性如何保存在物品的NBT标签中，包括：
- 元素属性的存储格式（列表、复合标签等）
- 元素数据的键值命名规范
- 版本兼容性处理
- 数据压缩和优化

良好的NBT结构设计确保了元素属性可以可靠地保存和加载，同时保持与未来版本的兼容性。

## 三、开发元素效果系统

### 7. 创建 ElementEffect 基类
**功能**：定义元素效果的基本行为和接口
**含义**：这个抽象基类定义了所有元素效果必须实现的方法，包括：
- 效果的应用方式（如何施加到目标）
- 效果的持续时间管理
- 效果的叠加规则
- 效果的视觉和音效表现

ElementEffect为所有具体的元素效果类提供了统一的接口，确保它们可以以一致的方式被系统调用和管理。

### 8. 实现各种元素效果的具体类
**功能**：实现每个元素的具体效果逻辑和触发机制
**含义**：每个元素类型都有对应的实现类，例如：
- StaggerEffect：实现冲击元素的蹒跚效果（触发后使敌人后退一格）
- BleedEffect：实现切割元素的出血效果（触发后造成基于武器伤害的真实伤害）
- FreezeEffect：实现冰冻元素的减速和冻结效果（触发后降低敌人速度，达到阈值时冻结）
- BurnEffect：实现火焰元素的燃烧效果（触发后减少护甲并造成持续火焰伤害）
- CorrosiveEffect：实现腐蚀元素的削甲效果（触发后按比例削减HamsterCore设定的护甲值）

**实现细节**：
- 每个效果类包含触发率参数和效果计算逻辑
- 触发判定基于武器伤害中该元素的占比和触发率
- 支持效果叠加、持续时间和层数管理
- 与HamsterCore的护甲系统、派系系统深度集成

这些类实现了元素的具体游戏机制，包括伤害计算、状态施加、视觉效果等，是实现"Warframe风格"元素战斗系统的核心组件。

### 9. 集成Minecraft的状态效果系统
**功能**：将元素效果与Minecraft原版的状态效果系统集成
**含义**：这部分工作包括：
- 创建自定义状态效果类
- 注册状态效果到游戏
- 处理状态效果的渲染和图标显示
- 管理状态效果的持续时间、叠加和移除

通过集成原版状态效果系统，可以确保元素效果与游戏其他系统（如药水效果、生物抗性等）正确交互。

## 四、构建伤害计算系统

### 10. 扩展现有的 FactionDamageHandler
**功能**：将元素属性集成到现有的派系伤害计算中
**含义**：这部分工作是对现有FactionDamageHandler的扩展，包括：
- 添加元素属性到伤害计算公式
- 处理元素效果与护甲的交互
- 考虑派系克制的元素加成
- 支持元素暴击和弱点攻击

通过扩展现有系统，可以保持代码的一致性和稳定性，同时添加元素属性功能。

### 11. 实现元素伤害计算逻辑
**功能**：计算包含元素属性的最终伤害值
**含义**：这部分实现了完整的元素伤害计算公式，包括：
- 基础物理伤害计算（冲击、穿刺、切割）
- 元素伤害计算（基础元素和复合元素）
- 护甲减免和元素抗性计算
- 暴击倍率和元素加成计算

伤害计算逻辑是元素属性系统的核心，它确保所有元素都能按照规划文档中的规则正确地影响伤害。

### 12. 集成派系克制关系
**功能**：实现派系与元素之间的克制关系
**含义**：这部分实现了规划文档中定义的派系克制关系，包括：
- 加载和应用派系克制倍率
- 处理复合元素的特殊克制关系
- 支持通过配置文件调整克制关系
- 在伤害计算中应用克制修正

派系克制关系增加了游戏的策略深度，不同的元素对不同派系的敌人有额外伤害或减弱效果。

## 五、实现UI显示功能

### 13. 创建武器元素属性显示界面
**功能**：显示武器上的元素属性和效果
**含义**：这部分创建了一个用户界面，用于：
- 显示武器上的所有元素属性
- 展示元素属性的具体数值和效果
- 提供元素组合预览功能
- 支持元素属性的调整和修改

这个界面是玩家与元素属性系统交互的主要方式，需要设计得直观易用。

### 14. 实现元素属性的提示信息
**功能**：在物品工具提示中显示元素信息
**含义**：这部分实现了物品悬停时的提示信息，包括：
- 显示元素的类型和数值
- 简短描述元素效果
- 使用颜色区分不同元素
- 支持多语言本地化

提示信息帮助玩家快速了解物品的元素属性，是提供良好用户体验的重要部分。

### 15. 添加自定义配置界面
**功能**：允许玩家和服主配置元素属性系统
**含义**：这部分提供了一个配置界面，支持：
- 调整元素属性的数值和效果
- 自定义派系克制关系
- 禁用或启用特定元素
- 导入和导出配置

配置界面使系统能够适应不同的游戏风格和平衡需求，增加了系统的灵活性和可定制性。

## 六、实现暴击与触发系统

### 16. 创建暴击属性系统
**功能**：实现暴击率属性的计算和应用
**含义**：这部分实现了暴击率属性，包括：
- 在ElementType枚举中添加CRITICAL_CHANCE类型
- 创建暴击率属性的计算和应用逻辑（参考Apothic的AttributeEvents.apothCriticalStrike方法）
- 实现多段暴击判定（连续暴击判定，每次降低效率）
- 支持不同装备的暴击率加成

**实现方式参考**：Apothic Attributes的CRIT_CHANCE属性，它通过Attribute系统实现暴击率，在LivingHurtEvent中进行判定，支持多段暴击判定机制。

暴击率属性决定了攻击时触发暴击的概率，影响伤害输出的稳定性和爆发性。

### 17. 实现暴击伤害系统
**功能**：实现暴击伤害的计算和倍率应用
**含义**：这部分实现了暴击伤害属性，包括：
- 在ElementType枚举中添加CRITICAL_DAMAGE类型
- 创建暴击伤害倍率属性的计算逻辑（参考Apothic的vanillaCritDmg方法）
- 实现暴击伤害与原版暴击系统的集成
- 支持暴击伤害的上限和平衡调整

**实现方式参考**：Apothic Attributes的CRIT_DAMAGE属性，它通过修改CriticalHitEvent来影响暴击伤害，同时与原版暴击系统兼容。

暴击伤害属性决定了触发暴击时的伤害增幅倍率，是提高伤害上限的重要手段。

### 18. 开发触发属性系统
**功能**：实现元素特殊效果的触发机制
**含义**：这部分实现了元素特殊效果的触发，包括：
- 为武器上的每个元素定义触发率属性（不是单独的属性，而是元素的固有特性）
- 实现基于元素占比和触发率的判定逻辑（造成伤害后计算触发概率）
- 设计触发效果的类型和参数（如腐蚀效果会削减护甲）
- 支持不同装备的触发率加成和冷却时间

**实现方式参考**：Apotheosis的Affix系统，触发概率作为每个元素的内部参数。例如：
- 腐蚀元素触发后，会按比例消减HamsterCore设定的怪物护甲值
- 切割元素触发后，会造成基于武器伤害的流血效果
- 冰冻元素触发后，会减速敌人并在达到阈值时冻结

**工作流程**：
1. 武器造成伤害后，系统检查武器上的所有元素类型和占比
2. 根据每个元素的触发率，独立判定是否触发特殊效果
3. 如果判定成功，应用对应元素的特殊效果（如腐蚀削减护甲）
4. 记录触发的冷却时间和叠加层数

触发属性是元素特殊效果与应用的桥梁，它决定了元素效果何时以及如何触发，是元素属性系统实现"Warframe风格"战斗机制的关键。

### 重要说明：为什么暴击、暴击伤害和触发不定义为枚举

根据Apotheosis和Apothic Attributes的实现方式，暴击、暴击伤害和触发**不应该定义为独立的枚举类型**，原因如下：

1. **暴击率和暴击伤害**：在Apothic Attributes中，这些是通过Forge的Attribute系统实现的，作为普通的属性类型，而不是枚举。它们通过修改实体的属性值来影响游戏行为。

2. **触发机制**：在Apotheosis中，触发是作为Affix的内部参数，而不是独立的类型。每个Affix类（如CleavingAffix）有自己的触发概率和触发逻辑。

3. **灵活性考虑**：作为参数而非枚举，可以更灵活地调整每个效果的触发条件，不需要为每种触发组合创建新的枚举值。

因此，在您的系统中：
- 暴击和暴击伤害应该作为ElementType枚举中的特殊类型，通过Attribute系统实现
- 触发应该作为每个元素效果的内部参数，在ElementEffect或ElementAttribute类中定义

## 七、集成暴击与触发到元素系统

### 19. 扩展ElementInstance类支持暴击和触发
**功能**：为元素属性实例添加暴击和触发支持
**含义**：这部分对ElementInstance类进行扩展，包括：
- 添加元素占比字段（表示该元素在武器总伤害中的占比）
- 添加元素触发率字段（决定该元素触发特殊效果的概率）
- 添加暴击率加成和暴击伤害倍率字段（影响该元素的暴击表现）
- 实现元素效果的触发判定和叠加逻辑
- 支持触发冷却时间和效果层数管理

**实现细节**：
- 每个ElementInstance代表武器上的一个元素属性及其相关参数
- 元素占比用于计算该元素在总伤害中的贡献度
- 触发率决定了该元素特殊效果的触发概率（如腐蚀效果的护甲削减）
- 触发成功后应用对应效果并记录冷却时间

通过扩展ElementInstance，每个元素属性都可以有完整的暴击和触发特性，实现了"Warframe风格"的元素战斗系统。

### 20. 实现元素暴击与触发的UI显示
**功能**：在用户界面中显示暴击和触发信息
**含义**：这部分实现了暴击和触发信息的UI显示，包括：
- 在武器属性界面中显示暴击率和暴击伤害
- 显示触发率和触发效果的描述
- 使用颜色和图标区分不同类型
- 支持多语言本地化

清晰的UI显示帮助玩家了解武器的暴击和触发特性，是提供良好用户体验的重要部分。

### 21. 集成暴击与触发到伤害计算
**功能**：将暴击和触发系统集成到伤害计算流程
**含义**：这部分将暴击和触发系统集成到现有的伤害计算中，包括：
- 在伤害计算前判定暴击和触发
- 应用暴击伤害倍率到最终伤害
- 处理触发效果的施加和计算
- 考虑暴击和触发的优先级和互斥关系

通过将暴击和触发系统集成到伤害计算流程，确保它们能够正确地影响游戏中的伤害输出和效果触发。

## 八、高级功能扩展

### 22. 实现暴击与触发的协同效果
**功能**：设计暴击与触发之间的协同机制
**含义**：这部分实现了暴击和触发的协同效果，包括：
- 设计暴击时提高触发率的机制
- 实现触发后增加暴击率的效果
- 创建暴击触发双倍效果的规则
- 支持自定义协同效果的配置

协同效果增加了系统的深度和策略性，使玩家可以追求特定的装备组合来获得更强的效果。

### 23. 添加暴击与触发的特殊视觉效果
**功能**：为暴击和触发事件添加视觉反馈
**含义**：这部分实现了暴击和触发的视觉效果，包括：
- 设计暴击时的粒子效果和屏幕震动
- 创建触发效果的特殊动画和音效
- 实现暴击和触发的伤害数字显示
- 支持自定义视觉效果和音效

视觉反馈增强了游戏的感官体验，使玩家能够直观地感受到暴击和触发的发生。

### 24. 实现暴击与触发的平衡调整系统
**功能**：提供暴击和触发属性的平衡调整工具
**含义**：这部分实现了平衡调整系统，包括：
- 创建暴击率和暴击伤害的平衡公式
- 设计触发率和触发效果的平衡曲线
- 提供不同游戏阶段的平衡调整
- 支持服务器端的统一平衡配置

平衡调整系统确保游戏的整体平衡性，防止某些属性过于强大或过于弱势。


请根据规则，检测ElementCombinationProcessor里的基础元素，复合元素中的方法是否正确。
这是我们基础元素进行复合元素的规则。

1.元素的顺序决定了元素伤害组合。

2.按照顺序，从上到下，依次复合

3.武器固有元素伤害则在上述计算完成后再组合添加进去

4.如果使用多个相同元素类型，最先使用的那个元素决定了该类型基础元素进行复合的次序。

5.本身含复合元素伤害的武器或被其他方式赋予了复合后的元素，保留复合元素，可组合特殊组合（如病毒+腐蚀）。

6.爆炸（火焰+冰冻），腐蚀（电击+毒素），毒气（火焰+毒素），磁力（冰冻+电击），辐射（火焰+电击），病毒（冰冻+毒素）。

7.参与复合的基础元素，效果将不生效。



示例武器默认有基础元素火0.5，现在给了武器单个元素冰0.5。那就组合成爆炸1。



默认有基础元素火0.5，现在给了武器单个元素冰0.5，电0.5.

那就组合成磁力1，火0.5.



默认有基础元素火0.5，现在给了武器单个元素冰0.5，电0.5,冰0.6.那就组合成磁力1.6，火0.5.



默认有基础元素火0.5，现在给了武器单个元素冰0.5，电0.5,毒0.5.那就组合成磁力1，毒气1.



默认有毒气0.5，现在给了武器单个元素冰0.5，火0.5,毒0.5.那就组合成爆炸1，毒气1.




以下是拔刀剑SlashBladeItemsFetcher.java的处理方法。
根据作者提示，可以使用modlist.isload判断是否有这个mod，如果有就可以直接调用API。
如果你用了这个模组的事件就千万别在那个事件类打总线注解
自己老老实实在游戏加载时post那个事件类
你调用了拔刀剑的do slash event
那么这种情况你就应该让那个类，没有总线注解而是自己在加载时在event bus里加

以及

Util是Minecraft原版提供的方法。

public String getTranslationKey(){

return Util.makeDescriptionId("item"，this.getName());
}


请根据以上内容，结合ck\SlashBlade_Resharped-master的源代码，处理SlashBladeItemsFetcher无法在世界加载阶段获取到全部拔刀剑的translationKey


我们先参考tacz的方式。但是要符合我们的需要。
1.我们的配置文件生成的数据文件格式应该为

"emxmors:emx_hvk30": {
    "gunId": "emxmors:emx_hvk30",
    "Basic": {
      [criticalChance，0.2，def ],
      [criticalDamage，0.5，def ], 
      [triggerChance，0.2，def ],  
      [slash，0.1，def ],
      [puncture，0.1，def ],
      [impact，0.1，def ],
    },
    "Computed": {
      [criticalChance，0.2，user ,add],
      [criticalDamage，0.5，user,add ], 
      [triggerChance，0.2，user,add ],  
      [slash，0.1，user ,add],
      [puncture，0.1，user,add ],
      [impact，0.1，user,add ],
    },
    "Usage": {
      [criticalChance，0.2],
      [criticalDamage，0.5 ], 
      [triggerChance，0.2],  
      [slash，0.1 ],
      [puncture，0.1],
      [impact，0.1 ],
    },
    "extra": {
      [Grineer，0.2,add],
    }
  }
我打算把nbt里的数据结构变成这样Basic里存储的为WeaponConfig.java设置的基础数据，由ElementApplier读取配置文件设置。
Computed里存储的为用于计算的数据，我们提供个api，由外部调用对里面进行设置
Usage里存储的为使用数据，在WeaponDataManager.java被调用时，WeaponDataManager利用modifier（元素复合modifier，专门对基础元素和复合元素处理，计算规则为ElementCombinationProcessor里复合元素部分。物理元素modifier，暴击modifier，暴击伤害modifier，触发率modifier。）计算后放入。
extra里为额外数据，仅在FactionDamageHandler里调用获取用于加入factionModifier的计算，用于对派系进行额外增伤或者减伤，只会为Add或者Sub
标识符分两种
1.def 或者user ，代表元素是默认的还是组合的，
2.Add、Sub、Mul、Div，代表这个元素的值用于哪种计算，在各个modifier里采用先加减后乘除方式。